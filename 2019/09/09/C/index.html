
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="UJoyBlog">
    <title>C++ - UJoyBlog</title>
    <meta name="author" content="Ujoy">
    
    
        <link rel="icon" href="https://Ujoy7851.github.io/assets/images/favicon.png">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Ujoy","sameAs":["https://github.com/Ujoy7851"],"image":"egg.jpg"},"articleBody":"\nC++ 개요특징C언어의 절차지향적 언어의 특징과 클래스를 사용하는 객체 지향적 언어의 특징을 가졌다. 동시에 템플릿으로 대변되는 일반화 프로그래밍 방식의 언어이다.\nC언어를 기초로 삼아 만들었기 때문에, C 표준 라이브러리를 사용할 수 있다.\nC++에서 소스 파일로부터 실행 파일을 생성하는 순서\n\n소스 파일의 작성 : .cpp 확장자로 된 소스 파일 작성\n선행처리 : #로 시작하는 선행처리 지시문의 처리 작업\n컴파일 : 기계어로 변환, 오브젝트 파일 생성(.o)\n링크 : 운영체제와의 인터페이스를 담당하는 시동 코드(start-up code)와 오브젝트 파일, 라이브러리 파일 등을 합쳐 하나의 실행 파일 생성(.exe)\n\n#include 문외부에 선언된 함수나 상수를 사용하기 위해서 헤더 파일의 내용을 현재 파일에 포함할 때 사용한다. C++에서는 헤더파일의 확장자를 사용하지 않는다. 기존 C언어 헤어 파일의 앞에 c를 추가하여 C++ 스타일의 헤더 파일로 변환하기도 한다.1#include &lt;cmath&gt;\n#define 문함수나 상수를 단순화해주는 매크로 정의\nnamespace이름이 기억되는 영역을 뜻하며, 이름에 대한 충돌을 방지해주는 방법을 제공한다.\nC++ 프로그램에서 표준 구성 요소인 클래스, 함수, 변수 등은 std라는 이름 공간에 저장되어 있으며 사용을 위해 std::를 붙어 해당 정의가 std라는 네임스페이스에 있다는 것을 컴파일러에게 알려주어야 한다.123456#include &lt;iostream&gt;int main() &#123;    std::cout&lt;&lt;\"hi!\";    return 0;&#125;\n네임스페이스에 속한 정의를 간단하게 사용하려면 다음 명령문을 추가해 네임스페이스 이름을 붙이지 않고 사용 가능하다.\n1using namespace std;\niostreamC++의 표준 입출력 클래스를 정의하고 있는 헤더파일이다. C++에서는 cout 객체가 출력 작업을, cin 객체가 입력 작업을 수행한다. C언어처럼 printf(), scanf() 함수로도 입출력 작업 수행 가능하다. C++ 표준 입출력 객체는 입출력 데이터의 타입을 자동으로 변환시켜준다.\n(scanf/printf가 cin/cout보다 빠르다.)\n123int age;std::cout&lt;&lt;\"나이를 입력하세요.\";std::cin&gt;&gt;age;\n\n&lt;&lt;(산입 연산자) : 출력할 데이터를 출력 스트림에 삽입\n>&gt;(추출 연산자) : 사용자가 입력한 데이터를 입력 스트림에서 추출해 오른쪽 변수에 저장\n\n\n타입변수변수란 데이터를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 의미한다. 저장된 값은 변경될 수 있다.\n변수 생성 규칙\n\n변수의 이름은 영문자(대소문자), 숫자, 언더스코어(_)로만 구성한다.\n변수의 이름은 숫자로 시작될 수 없다.\n변수의 이름 사이에는 공백을 포함할 수 없다.\n변수의 이름으로 C++에서 미리 정의된 키워드(keyword)는 사용할 수 없다.\n변수 이름의 길이에는 제한이 없다.\n대소문자는 구분된다.\n\n변수를 선언한 뒤 초기화하지 않으면 해당 메모리 공간에는 쓰레기값이 들어있다. 또한 다른 타입의 데이터를 저장할 경우 저장한 데이터에 변형이 일어날 수 있다.\n상수변수처럼 데이터를 저장할 수 있는 메모리 공간을 의미하지만 프로그램이 실행되는 동안 메모리에 저장된 데이터를 변경할 수 없다. 상수 표현 방식에 따라 리터럴 상수와 심볼릭 상수로 나뉜다.\n\n리터럴 상수(literal constant) : 변수와 달리 메모리 공간을 가리키는 이름을 가지고 있지 않다. 타입에 따라 정수형, 실수형, 문자형 리터럴 상수로 구분할 수 있다.\n\n정수형 : 10진수, 8진수(0으로 시작), 16진수(0x로 시작)로 표현할 수 있다. 여러 가지 진법으로 표현된 정수형 상수의 출력을 위해 cout 객체는 dec, hex, oct 조정자를 제공한다. 정수형 리터럴 상수는 데이터의 값이 너무 커서 int형으로 저장할 수 없거나, 접미사를 사용해 해당 상수의 타입을 직접 명시하는 경우를 제외하고 모두 int형으로 저장된다.\n  1234567int  a  =  10;cout&lt;&lt;\"숫자 10을 10진수로 표현하면 \"&lt;&lt;a&lt;&lt;\"이며, \"&lt;&lt;endl;cout&lt;&lt;oct;cout&lt;&lt;\"숫자 10을 8진수로 표현하면 \"&lt;&lt;a&lt;&lt;\"이며, \"&lt;&lt;endl;cout&lt;&lt;hex;cout&lt;&lt;\"숫자 10을 16진수로 표현하면 \"&lt;&lt;a&lt;&lt;\" 입니다.\";\n  |접미사| 타입 |  |–|–|  | 기본설정 | (signed) int |  | u 또는 U | unsigned int |  | l 또는 L | (signed) long |  | ul 또는 uL 또는 Ul 또는 UL | unsigned long형 |  |long long 또는 u11 또는 U11 또는 uLL 또는 ULL | unsigned long long형 (C++11부터 제공) |\n\n\n\n실수형 : 실수형 리터럴 상수는 모두 double형으로 저장되며 부동 소수점 방식으로 저장된다. 접미사를 추가하여 저장되는 타입을 직접 명시할 수도 있다.\n| 접미사 | 타입 ||–|–|| f 또는 F | float ||기본 설정| double ||l 또는 L| long double |\n\n포인터 : nullptr 키워드를 사용해 널 포인터를 표현할 수 있다. nullptr 키워드를 사용한 리터럴 상수의 타입은 포인터 타입이며, 정수형으로 변환할 수 없다. (0으로 포인터를 초기화해 널 포인터를 표현할 수 도 있지만 nullptr를 사용하는 것이 더 안전하다.)\n\n이진 : 0B 또는 0b 접두사와 0과 1의 시퀀스를 가지고 이진 리터럴 상수를 표현할 수 있다.\n\n\n심볼릭 상수(symbolic constant) : 변수와 마찬가지로 이름을 가진 상수이다. 선언과 동시에 반드시 초기화해야 한다. 매크로를 이용하거나 const 키워드를 사용하여 선언할 수 있다. C++에서는 가급적 const 키워드를 사용하는 것이 좋다.  1cosnt int ages = 30;\n\n\n기본 타입타입은 해당 데이터가 메모리에 어떻게 저장되고, 어떻게 처리되어야 하는지를 명시적으로 알려준다. 기본 타입은 크게 정수형, 실수형, 문자형, bool형 타입으로 나뉜다.\n\n정수형 : 부호를 가진 소수 부분이 없는 수. unsigned는 부호를 나타내는 최상위 비트(MSB)까지 크기를 나타내는데 사용한다. 컴퓨터는 내부적으로 정수형 중에서도 int형의 데이터를 가장 빠르게 처리한다.\n  |정수형 타입|할당되는 메모리의 크기|데이터의 표현 범위|  |–|–|–|  |(signed) short|2 바이트|-2^15 ~ (2^15 - 1)|  |unsigned short|2 바이트|0 ~ (2^16 - 1)|  |(signed) int|4 바이트|-2^31 ~ (2^31 - 1)|  |unsigned int|4 바이트|0 ~ (2^32 - 1)|  |(signed) long|4 바이트|-2^31 ~ (2^31 - 1)|  |unsigned long|4 바이트|0 ~ (2^32 - 1)|  |unsigned long long|8 바이트|0 ~ (2^64 - 1)|\n\n실수형 타입 : 정수보다 더 넓은 표현 범위를 가지지만 컴퓨터가 실수를 표현하는 방식은 오차가 발생할 수 밖에 없다. float형은 소수점 6자리, double형은 15자리까지 오차없이 표현 가능하다.\n  |실수형 타입|할당되는 메모리의 크기|데이터의 표현 범위|  |–|–|–|  |float|4 바이트|(3.4 X 10-^38) ~ (3.4 X 10^38)|  |double|8 바이트|(1.7 X 10^-308) ~ (1.7 X 10^308)|  |long double|double형과 동일함.|double형과 동일함.|\n\n문자형 타입 : 문자형 데이터는 작은 정수나 문자 하나를 표현할 수 있다.\n  |문자형 타입|할당되는 메모리의 크기|데이터의 표현 범위|  |–|–|–|  |(signed) char|1 바이트|2^-7 ~(2^7 - 1)|  |unsigned char|2 바이트|0 ~ 2^8|\n\nbool형 타입 : C++11부터 bool형 타입을 제공하며, true나 false 중 한 가지 값만을 가질 수 있다. 또한 어떤 값도 묵시적 타입 변환이 가능해 0인 값은 false로 나머지 값은 true로 자동 변환된다.\n\n\n* C++11부터 auto 키워드를 이용해 변수의 초깃값에 맞춰 변수의 타입이 자동으로 선언되게 할 수 있다.\n부동 소수점 수컴퓨터에서 실수를 2진수로 표현하기 위한 방식에는 고정 소수점 방식과 부동 소수점 방식이 있다.\n\n고정 소수점 방식(fixed point) : 실수는 정수부와 소수부로 나눌 수 있다. 고정 소수점 방식은 고정된 소수부 자릿수를 미리 정해 실수를 표현한다. 정수부와 소수부의 자릿수가 크지 않아 표현할 수 있는 범위가 적다.\n\n부동 소수점 방식(floating point) : 실수를 가수부와 지수부로 나누어 표현한다.±(1.가수부)×2^(지수부-127)라는 수식을 이용해 매우 큰 실수까지도 표현 가능하며, 대부분의 시스템은 부동 소수점 방식을 택한다. 하지만 부동 소수점 방식에 의한 실수 표현에는 항상 오차가 존재한다.\n\n\n타입 변환다른 타입끼리의 연산은 피연산자들을 모두 같은 타입으로 만든 후에 수행된다. 다음과 같은 경우 자동으로 타입 변환이 수행된다.\n\n다른 타입끼리의 대입, 산수 연산 시\n함수에 인수를 전달할 때\n\n표현 범위가 좁은 타입에서 표현 범위가 더 넓은 타입으로 변환 시에는 문제가 없지만 반대의 경우에서의 타입 변환은 데이터 손실이 발생한다.\n타입 변환의 종류\n\n묵시적 타입 변환(자동) : 대입, 산술 연산에서 컴파일러가 자동으로 수행하는 타입 변환이다. 대입 연산에서는 연산자의 오른쪽에 존재하는 데이터의 타입이 왼쪽에 존재하는 데이터 타입으로 변환된다. 산술 연산 시에는 데이터의 손실이 최소화되는 방향으로 타입변환이 진행된다. (char형 → short형 → int형 → long형 → float형 → double형 → long double형)\n  123456int num1 = 3.1415;  //num1에 저장된 값 : 3. narrowing cast. 데이터 손실int num2 = 8.3E12;  //num2에 저장된 값 : 2147483647, int형 저장 범위를 초과함double num3 = 5;    //num3에 저장된 값 : 5double result1 = 5 + 3.14;   //int형 데이터가 double형으로 자동 타입 변환됨.double result2 = 5.0f + 3.14;   //float형 데이터가 double형으로 자동 타입 변환됨.\n  *산술 연산 시 bool형 데이터인 true는 1로, false는 0으로 자동 타입 변환된다.\n\n명시적 타입 변환(강제) : 사용자가 타입 캐스트 연산자를 사용해 강제적으로 수행한다.\n\n(변환할타입) 변환할데이터\n변환할타입 (변환할데이터)12345int num1 = 1;int num2 = 4;double result1 = num1 / num2;   //0 (int형 데이터끼리의 산술 연산에 대한 결과값은 int형이다.)double result2 = (double) num1 / num2;  //0.25double result3 = double (num1) / num2;  //0.25\n\n\n\n\n\n연산자산술 연산자+, -, *, /, %\n대입 연산자=, +=, -=, *=, /=, %=\n증감 연산자++x, x++, –x, x–\n비교 연산자==, !=, &gt;, &lt;, &gt;=, &lt;=\n논리 연산자&amp;&amp;, ||, !\n비트 연산자&amp;, |, ^(xor, 같으면 0 다르면 1), ~(not, 1의 보수), &lt;&lt;(left shift), &gt;&gt;(right shift, 부호를 유지한다.)\n기타 연산자\n삼항 연산자 : 조건식 ? 반환값1 : 반환값2\n쉼표 연산자 : 둘 이상의 변수를 동시에 선언하거나 둘 이상의 인수를 함수로 전달할 때\nsizeof : 피연산자의 크기를 바이트 단위로 반환한다.C++ 연산자\n범위 지정 연산자(::)\n\n::식별자\n클래스이름::식별자\n네임스페이스::식별자\n열거체::식별자\n\n\n멤버 포인터 연산자\n\n클래스타입의객체.*멤버이름\n클래스타입객체의포인터-&gt;*멤버이름\n\n\ntypreid 연산자 : 객체의 타입 반환. 런타임에 객체의 타입을 결정하거나, 템플릿에서 템플릿 매개변수의 타입을 결정할 떄 사용한다.\n  typeid(표현식)\n\n\n\n제어문조건문\nif 문\n1234if (조건식)&#123;    명령문;&#125;\n\nif/else 문\n123456if (조건식)&#123;    명령문;&#125; else &#123;    명령문;&#125;\n\nif/else if/ else 문\n12345678if (조건식)&#123;    명령문;&#125; else if &#123;    명령문;&#125; else &#123;    명령문;&#125;\n\nswitch 문\n12345678910111213switch(조건 값)&#123;    case 값1:        명령문;        break;    case 값2:    case 값3:        명령문;        break;    default:        명령문;        break;&#125;\n\n\n반복문\nwhile 문\n  1234while(조건식&#123;    명령문;&#125;\n\ndo/while 문\n  123do &#123;    명령문;&#125; while (조건식);\n\nfor 문\n  1234for (초기식; 조건식; 증감식)&#123;    명령문;&#125;\n\n범위 기반 for 문 : 표현식 안에 포함되어 있는 모든 값에 대해 한 번씩 루프를 실행해준다. 배열을 자동으로 인식하며, 컨테이너 클래스에서 많이 사용된다.\n  12345int arr[5] = &#123;1, 2,3, 4, 5&#125;;for(int element : arr)&#123;    cout&lt;&lt;element&lt;&lt;endl;&#125;\n\n\n기타 제어문반복문의 흐름을 사용자가 직접 제어하도록 도와준다.\n\ncontinue 문 : 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고 바로 다음 조건식의 판단으로 넘어가게 해준다.\nbreak 문 : 루프 내에서 사용하여 해당 반복문을 종료시킨다.\ngoto 문 : 프로그램의 흐름을 지정된 레이블로 무조건 변경시킨다. 프로그램의 흐름을 복잡하게 만들어 디버깅 이외에 거의 사용되지 않는다.\n\n\n배열과 포인터배열(array)은 같은 타입의 변수들로 이루어진 유한 집합이다. 배열을 구성하는 각각의 값을 element, 배열에서의 위치를 가리키는 숫자를 index 라고한다.\n1차원 배열1234567891011121314//배열 선언 : 타입 배열이름[배열길이];int grade[3];grade[0] = 85;grade[0] = 90;grade[0] = 80;int age[3] = &#123;20, 32&#125;;  //초기화되지 못한 나머지는 0으로 초기화된다.int age2[3] = &#123;&#125;;   //전부 0으로 초기화된다.int grade2[3];grade2 = grade; //error//배열의 길이를 입력하지 않으면 초기화 리스트에 맞춰 자동으로 길이가 설정된다.int arr[] = &#123;1, 2, 3&#125;;\n\n선언만 하고 초기화하지 않으면, 모든 배열 요소가 쓰레기값으로 채워진다.\n배열의 이름은 배열의 첫 번째 요소와 같은 주소를 가리킨다. (grade = grade[0]의 주소)\nC++ 컴파일러는 배열의 길이 등을 일일이 검사하여 오류를 출력해 주지 않는다. 존재하지 않는 인덱스에 접근해도 오류가 없으니 주의해야 한다.\n배열이 차지하는 메모리의 크기 = 배열의 길이 X sizeof(타입)\n배열의 길이 = sizeof(배열 이름) / sizeof(배열 이름[0])\n\n다차원 배열2차원 이상의 배열로, 배열 요소로 또 다른 배열을 가지는 배열이다.12345678910111213141516171819202122//선언타입 배열이름[행의길이][열의길이];//초기화 방식1int arr1[3][5] = &#123;1, 2, ... , 15&#125;;//초기화 방식2int arr2[3][5] = &#123;    &#123;1, 2, ...&#125;,    &#123;6, 7, ...&#125;,    ...&#125;//초기화 방식3int arr3[3][5] = &#123;    &#123;10, 20&#125;,    &#123;30, 40, 50, 60, 0&#125;,    &#123;0, 0, 70, 80&#125;&#125;;// 열의 길이int arr_col_len = sizeof(arr[0]) / sizeof(arr[0][0]);\n2차원 배열에서 열의 길이는 생략할 수 있지만, 행의 길이는 반드시 명시해야 한다. 행의 길이 생략시 컴파일 오류 발생.\n포인터 개념\n주소값 : 데이터가 저장된 메모리의 시작 주소를 의미한다.\n포인터 : 메모리의 주소값을 저장하는 변수로, 포인터 변수라고도 부른다.\n  12345int n = 100;   // 변수의 선언int *ptr = &amp;n; // 포인터의 선언int **pptr = &amp;ptr;int *ptr1, ptr2;    //ptr1은 int형 포인터, ptr2는 int형 변수로 선언된다.\n\n주소 연산자(&amp;) : 변수 이름 앞에 사용하여, 변수의 주소값을 반환한다.\n\n참조 연산자(*) : 포인터의 이름이나 주소 앞에 사용하여, 포인터에 저장된 주소에 저장되어 있는 값을 반환한다.\n포인터의 타입은 참조 연산자를 통해 값을 참조할 때, 참조할 메모리의 크기를 알려주는 역할을 한다.\n\n포인터 연산&lt;포인터 연산 규칙&gt;\n\n포인터끼리의 덧셈, 곱셈, 나눗셈은 아무런 의미가 없다.\n포인터끼리의 뺄셈은 두 포인터 사이의 상대적 거리를 나타낸다.\n포인터에 정수를 더하거나 뺄 수는 있지만, 실수와의 연산은 허용하지 않는다.\n포인터끼리 대입하거나 비교할 수 있다.\n\n\n포인터 연산 후 각각의 포인터가 가리키는 주소의 증가, 감소 폭은 포인터가 가리키는 변수의 타입에 따라 다르다. (예를들어, int형 포인터는 4바이트씩 증가, 감소한다.)\n배열의 이름은 값을 변경할 수 없는 상수라는 점을 제외하면 포인터와 같다. 배열의 이름은 해당 배열의 첫 번째 요소의 주소와 같다. (arr가 포인터 또는 배열일 때, arr[n] == *(arr+n))\n  12345678int arr[3] = &#123;1, 2, 3&#125;;int *ptr = arr;cout&lt;&lt;ptr[0]&lt;&lt;\", \"&lt;&lt;ptr[1]&lt;&lt;\", \"&lt;&lt;ptr[2]&lt;&lt;endl; //1, 2, 3cout&lt;&lt;*(arr+0)&lt;&lt;\", \"&lt;&lt;*(arr+1)&lt;&lt;\", \"&lt;&lt;*(arr+2)&lt;&lt;endl;   //1, 2, 3cout&lt;&lt;sizeof(arr)&lt;&lt;endl;    //12cout&lt;&lt;sizeof(ptr)&lt;&lt;endl;    //8\n  * 포인터를 이용한 크기 계산에서는 배열의 크기가 아닌 포인터 변수의 크기가 출력된다.\n\n포인터 연산으로 배열의 크기를 넘어서는 접근을 해도 컴파일러 오류가 발생하지 않는다.\n\n메모리 동적 할당데이터 영역과 스택 영역에 할당되는 메모리는 컴파일 타임에 미리 결정된다. 하지만 힙 영역의 크기는 런 타임에 사용자가 직접 결정하게 되며, 런 타임에 메모리를 할당받는 것을 메모리 동작 할당이라고 한다.\n포인터를 통해 런 타임에 메모리를 할당받아 포인터에 할당, 할당받은 메모리에 접근할 수 있다.\nC++에서는 C언어의 라이브러리 함수를 통해서도 동적 할당 및 해제가 가능하지만 new, delete 연산자를 통한 방법이 효과적이다.\n\nnew 연산자 : 자유 기억 공간(free store)라는 메모리 공간(memory pool)에 객체를 위한 메모리를 할당받는다. new를 통해 할당받은 메모리는 이름이 없어 해당 포인터로만 접근이 가능하며, 사용할 수 있는 메모리가 부족해 메모리를 만들지 못한 경우 널 포인터를 반환한다.\ndelete 연산자 : 사용하지 않는 메모리를 다시 메모리 공간에 돌려준다.\n\n1234567891011///타입* 포인터이름 = new 타입;int *ptr_int = new int;*ptr_int = 100;double *ptr_double = new double;*ptr_double = 100.123;...delete ptr_int;delete ptr_double;\n","dateCreated":"2019-09-09T18:07:15+09:00","dateModified":"2019-09-10T02:19:03+09:00","datePublished":"2019-09-09T18:07:15+09:00","description":"알고리즘 공부를 위한 C++ 기본 정리","headline":"C++","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"https://Ujoy7851.github.io/2019/09/09/C/"},"publisher":{"@type":"Organization","name":"Ujoy","sameAs":["https://github.com/Ujoy7851"],"image":"egg.jpg","logo":{"@type":"ImageObject","url":"egg.jpg"}},"url":"https://Ujoy7851.github.io/2019/09/09/C/","keywords":"C++"}</script>
    <meta name="description" content="알고리즘 공부를 위한 C++ 기본 정리">
<meta name="keywords" content="C++">
<meta property="og:type" content="blog">
<meta property="og:title" content="C++">
<meta property="og:url" content="https://Ujoy7851.github.io/2019/09/09/C/index.html">
<meta property="og:site_name" content="UJoyBlog">
<meta property="og:description" content="알고리즘 공부를 위한 C++ 기본 정리">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://tcpschool.com/lectures/img_c_programming.png">
<meta property="og:updated_time" content="2019-09-09T17:19:03.267Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++">
<meta name="twitter:description" content="알고리즘 공부를 위한 C++ 기본 정리">
<meta name="twitter:image" content="http://tcpschool.com/lectures/img_c_programming.png">
    
    
        
    
    
        <meta property="og:image" content="https://Ujoy7851.github.io/assets/images/egg.jpg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-c4ozcsklz4kht2pebhp44xorvyverh23toayhn7i6ubrpyedak24hv1v0hyd.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">UJoyBlog</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="/assets/images/egg.jpg" alt="Author&#39;s picture">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/egg.jpg" alt="Author&#39;s picture">
                </a>
                <h4 class="sidebar-profile-name">Ujoy</h4>
                
                    <h5 class="sidebar-profile-bio"><p>기억력을 믿지 못해 블로그를 시작했다.</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="Home">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-categories" title="Categories">
                    
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-tags" title="Tags">
                    
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/all-archives" title="Archives">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="#search" title="Search">
                    
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="#about" title="About">
                    
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="https://github.com/Ujoy7851" target="_blank" rel="noopener" title="GitHub">
                    
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/atom.xml" title="RSS">
                    
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            C++
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-09-09T18:07:15+09:00">
	
		    Sep 09, 2019
    	
    </time>
    
        <span>in </span>
        
    <a class="category-link" href="/categories/Programming/">Programming</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <!-- excerpt --><p></p>
<h3 id="C-개요"><a href="#C-개요" class="headerlink" title="C++ 개요"></a>C++ 개요</h3><h4 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h4><p>C언어의 절차지향적 언어의 특징과 클래스를 사용하는 객체 지향적 언어의 특징을 가졌다. 동시에 템플릿으로 대변되는 일반화 프로그래밍 방식의 언어이다.</p>
<p>C언어를 기초로 삼아 만들었기 때문에, C 표준 라이브러리를 사용할 수 있다.</p>
<h4 id="C-에서-소스-파일로부터-실행-파일을-생성하는-순서"><a href="#C-에서-소스-파일로부터-실행-파일을-생성하는-순서" class="headerlink" title="C++에서 소스 파일로부터 실행 파일을 생성하는 순서"></a>C++에서 소스 파일로부터 실행 파일을 생성하는 순서</h4><p><img src="http://tcpschool.com/lectures/img_c_programming.png" alt></p>
<ul>
<li>소스 파일의 작성 : .cpp 확장자로 된 소스 파일 작성</li>
<li>선행처리 : #로 시작하는 선행처리 지시문의 처리 작업</li>
<li>컴파일 : 기계어로 변환, 오브젝트 파일 생성(.o)</li>
<li>링크 : 운영체제와의 인터페이스를 담당하는 시동 코드(start-up code)와 오브젝트 파일, 라이브러리 파일 등을 합쳐 하나의 실행 파일 생성(.exe)</li>
</ul>
<h4 id="include-문"><a href="#include-문" class="headerlink" title="#include 문"></a>#include 문</h4><p>외부에 선언된 함수나 상수를 사용하기 위해서 헤더 파일의 내용을 현재 파일에 포함할 때 사용한다. C++에서는 헤더파일의 확장자를 사용하지 않는다. 기존 C언어 헤어 파일의 앞에 c를 추가하여 C++ 스타일의 헤더 파일로 변환하기도 한다.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="define-문"><a href="#define-문" class="headerlink" title="#define 문"></a>#define 문</h4><p>함수나 상수를 단순화해주는 매크로 정의</p>
<h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><p>이름이 기억되는 영역을 뜻하며, 이름에 대한 충돌을 방지해주는 방법을 제공한다.</p>
<p>C++ 프로그램에서 표준 구성 요소인 클래스, 함수, 변수 등은 std라는 이름 공간에 저장되어 있으며 사용을 위해 std::를 붙어 해당 정의가 std라는 네임스페이스에 있다는 것을 컴파일러에게 알려주어야 한다.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"hi!"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>네임스페이스에 속한 정의를 간단하게 사용하려면 다음 명령문을 추가해 네임스페이스 이름을 붙이지 않고 사용 가능하다.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure>
<h4 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a>iostream</h4><p>C++의 표준 입출력 클래스를 정의하고 있는 헤더파일이다. C++에서는 cout 객체가 출력 작업을, cin 객체가 입력 작업을 수행한다. C언어처럼 printf(), scanf() 함수로도 입출력 작업 수행 가능하다. C++ 표준 입출력 객체는 입출력 데이터의 타입을 자동으로 변환시켜준다.</p>
<p>(scanf/printf가 cin/cout보다 빠르다.)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"나이를 입력하세요."</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;age;</span><br></pre></td></tr></table></figure>
<ul>
<li>&lt;&lt;(산입 연산자) : 출력할 데이터를 출력 스트림에 삽입</li>
<li>>&gt;(추출 연산자) : 사용자가 입력한 데이터를 입력 스트림에서 추출해 오른쪽 변수에 저장</li>
</ul>
<hr>
<h3 id="타입"><a href="#타입" class="headerlink" title="타입"></a>타입</h3><h4 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h4><p>변수란 데이터를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 의미한다. 저장된 값은 변경될 수 있다.</p>
<p><strong>변수 생성 규칙</strong></p>
<ul>
<li>변수의 이름은 영문자(대소문자), 숫자, 언더스코어(_)로만 구성한다.</li>
<li>변수의 이름은 숫자로 시작될 수 없다.</li>
<li>변수의 이름 사이에는 공백을 포함할 수 없다.</li>
<li>변수의 이름으로 C++에서 미리 정의된 키워드(keyword)는 사용할 수 없다.</li>
<li>변수 이름의 길이에는 제한이 없다.</li>
<li>대소문자는 구분된다.</li>
</ul>
<p>변수를 선언한 뒤 초기화하지 않으면 해당 메모리 공간에는 쓰레기값이 들어있다. 또한 다른 타입의 데이터를 저장할 경우 저장한 데이터에 변형이 일어날 수 있다.</p>
<h4 id="상수"><a href="#상수" class="headerlink" title="상수"></a>상수</h4><p>변수처럼 데이터를 저장할 수 있는 메모리 공간을 의미하지만 프로그램이 실행되는 동안 메모리에 저장된 데이터를 변경할 수 없다. 상수 표현 방식에 따라 리터럴 상수와 심볼릭 상수로 나뉜다.</p>
<ul>
<li><p>리터럴 상수(literal constant) : 변수와 달리 메모리 공간을 가리키는 이름을 가지고 있지 않다. 타입에 따라 정수형, 실수형, 문자형 리터럴 상수로 구분할 수 있다.</p>
<ul>
<li><p>정수형 : 10진수, 8진수(0으로 시작), 16진수(0x로 시작)로 표현할 수 있다. 여러 가지 진법으로 표현된 정수형 상수의 출력을 위해 cout 객체는 dec, hex, oct 조정자를 제공한다. 정수형 리터럴 상수는 데이터의 값이 너무 커서 int형으로 저장할 수 없거나, 접미사를 사용해 해당 상수의 타입을 직접 명시하는 경우를 제외하고 모두 int형으로 저장된다.</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  a  =  <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"숫자 10을 10진수로 표현하면 "</span>&lt;&lt;a&lt;&lt;<span class="string">"이며, "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;oct;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"숫자 10을 8진수로 표현하면 "</span>&lt;&lt;a&lt;&lt;<span class="string">"이며, "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;hex;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"숫자 10을 16진수로 표현하면 "</span>&lt;&lt;a&lt;&lt;<span class="string">" 입니다."</span>;</span><br></pre></td></tr></table></figure>
<p>  |접미사| 타입 |<br>  |–|–|<br>  | 기본설정 | (signed) int |<br>  | u 또는 U | unsigned int |<br>  | l 또는 L | (signed) long |<br>  | ul 또는 uL 또는 Ul 또는 UL | unsigned long형 |<br>  |long long 또는 u11 또는 U11 또는 uLL 또는 ULL | unsigned long long형 (C++11부터 제공) |</p>
</li>
</ul>
<ul>
<li><p>실수형 : 실수형 리터럴 상수는 모두 double형으로 저장되며 부동 소수점 방식으로 저장된다. 접미사를 추가하여 저장되는 타입을 직접 명시할 수도 있다.</p>
<p>| 접미사 | 타입 |<br>|–|–|<br>| f 또는 F | float |<br>|기본 설정| double |<br>|l 또는 L| long double |</p>
</li>
<li><p>포인터 : nullptr 키워드를 사용해 널 포인터를 표현할 수 있다. nullptr 키워드를 사용한 리터럴 상수의 타입은 포인터 타입이며, 정수형으로 변환할 수 없다. (0으로 포인터를 초기화해 널 포인터를 표현할 수 도 있지만 nullptr를 사용하는 것이 더 안전하다.)</p>
</li>
<li>이진 : 0B 또는 0b 접두사와 0과 1의 시퀀스를 가지고 이진 리터럴 상수를 표현할 수 있다.</li>
</ul>
</li>
<li>심볼릭 상수(symbolic constant) : 변수와 마찬가지로 이름을 가진 상수이다. 선언과 동시에 반드시 초기화해야 한다. 매크로를 이용하거나 const 키워드를 사용하여 선언할 수 있다. C++에서는 가급적 const 키워드를 사용하는 것이 좋다.  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cosnt <span class="keyword">int</span> ages = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="기본-타입"><a href="#기본-타입" class="headerlink" title="기본 타입"></a>기본 타입</h4><p>타입은 해당 데이터가 메모리에 어떻게 저장되고, 어떻게 처리되어야 하는지를 명시적으로 알려준다. 기본 타입은 크게 정수형, 실수형, 문자형, bool형 타입으로 나뉜다.</p>
<ul>
<li><p>정수형 : 부호를 가진 소수 부분이 없는 수. unsigned는 부호를 나타내는 최상위 비트(MSB)까지 크기를 나타내는데 사용한다. 컴퓨터는 내부적으로 정수형 중에서도 int형의 데이터를 가장 빠르게 처리한다.</p>
<p>  |정수형 타입|할당되는 메모리의 크기|데이터의 표현 범위|<br>  |–|–|–|<br>  |(signed) short|2 바이트|-2^15 ~ (2^15 - 1)|<br>  |unsigned short|2 바이트|0 ~ (2^16 - 1)|<br>  |(signed) int|4 바이트|-2^31 ~ (2^31 - 1)|<br>  |unsigned int|4 바이트|0 ~ (2^32 - 1)|<br>  |(signed) long|4 바이트|-2^31 ~ (2^31 - 1)|<br>  |unsigned long|4 바이트|0 ~ (2^32 - 1)|<br>  |unsigned long long|8 바이트|0 ~ (2^64 - 1)|</p>
</li>
<li><p>실수형 타입 : 정수보다 더 넓은 표현 범위를 가지지만 컴퓨터가 실수를 표현하는 방식은 오차가 발생할 수 밖에 없다. float형은 소수점 6자리, double형은 15자리까지 오차없이 표현 가능하다.</p>
<p>  |실수형 타입|할당되는 메모리의 크기|데이터의 표현 범위|<br>  |–|–|–|<br>  |float|4 바이트|(3.4 X 10-^38) ~ (3.4 X 10^38)|<br>  |double|8 바이트|(1.7 X 10^-308) ~ (1.7 X 10^308)|<br>  |long double|double형과 동일함.|double형과 동일함.|</p>
</li>
<li><p>문자형 타입 : 문자형 데이터는 작은 정수나 문자 하나를 표현할 수 있다.</p>
<p>  |문자형 타입|할당되는 메모리의 크기|데이터의 표현 범위|<br>  |–|–|–|<br>  |(signed) char|1 바이트|2^-7 ~(2^7 - 1)|<br>  |unsigned char|2 바이트|0 ~ 2^8|</p>
</li>
<li><p>bool형 타입 : C++11부터 bool형 타입을 제공하며, true나 false 중 한 가지 값만을 가질 수 있다. 또한 어떤 값도 묵시적 타입 변환이 가능해 0인 값은 false로 나머지 값은 true로 자동 변환된다.</p>
</li>
</ul>
<p>* C++11부터 auto 키워드를 이용해 변수의 초깃값에 맞춰 변수의 타입이 자동으로 선언되게 할 수 있다.</p>
<h4 id="부동-소수점-수"><a href="#부동-소수점-수" class="headerlink" title="부동 소수점 수"></a>부동 소수점 수</h4><p>컴퓨터에서 실수를 2진수로 표현하기 위한 방식에는 고정 소수점 방식과 부동 소수점 방식이 있다.</p>
<ul>
<li><p>고정 소수점 방식(fixed point) : 실수는 정수부와 소수부로 나눌 수 있다. 고정 소수점 방식은 고정된 소수부 자릿수를 미리 정해 실수를 표현한다. 정수부와 소수부의 자릿수가 크지 않아 표현할 수 있는 범위가 적다.</p>
</li>
<li><p>부동 소수점 방식(floating point) : 실수를 가수부와 지수부로 나누어 표현한다.<br><code>±(1.가수부)×2^(지수부-127)</code>라는 수식을 이용해 매우 큰 실수까지도 표현 가능하며, 대부분의 시스템은 부동 소수점 방식을 택한다. 하지만 부동 소수점 방식에 의한 실수 표현에는 항상 오차가 존재한다.</p>
</li>
</ul>
<h4 id="타입-변환"><a href="#타입-변환" class="headerlink" title="타입 변환"></a>타입 변환</h4><p>다른 타입끼리의 연산은 피연산자들을 모두 같은 타입으로 만든 후에 수행된다. 다음과 같은 경우 자동으로 타입 변환이 수행된다.</p>
<ul>
<li>다른 타입끼리의 대입, 산수 연산 시</li>
<li>함수에 인수를 전달할 때</li>
</ul>
<p>표현 범위가 좁은 타입에서 표현 범위가 더 넓은 타입으로 변환 시에는 문제가 없지만 반대의 경우에서의 타입 변환은 데이터 손실이 발생한다.</p>
<p><strong>타입 변환의 종류</strong></p>
<ul>
<li><p>묵시적 타입 변환(자동) : 대입, 산술 연산에서 컴파일러가 자동으로 수행하는 타입 변환이다. 대입 연산에서는 연산자의 오른쪽에 존재하는 데이터의 타입이 왼쪽에 존재하는 데이터 타입으로 변환된다. 산술 연산 시에는 데이터의 손실이 최소화되는 방향으로 타입변환이 진행된다. (char형 → short형 → int형 → long형 → float형 → double형 → long double형)</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = <span class="number">3.1415</span>;  <span class="comment">//num1에 저장된 값 : 3. narrowing cast. 데이터 손실</span></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">8.3E12</span>;  <span class="comment">//num2에 저장된 값 : 2147483647, int형 저장 범위를 초과함</span></span><br><span class="line"><span class="keyword">double</span> num3 = <span class="number">5</span>;    <span class="comment">//num3에 저장된 값 : 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> result1 = <span class="number">5</span> + <span class="number">3.14</span>;   <span class="comment">//int형 데이터가 double형으로 자동 타입 변환됨.</span></span><br><span class="line"><span class="keyword">double</span> result2 = <span class="number">5.0f</span> + <span class="number">3.14</span>;   <span class="comment">//float형 데이터가 double형으로 자동 타입 변환됨.</span></span><br></pre></td></tr></table></figure>
<p>  *산술 연산 시 bool형 데이터인 true는 1로, false는 0으로 자동 타입 변환된다.</p>
</li>
<li><p>명시적 타입 변환(강제) : 사용자가 타입 캐스트 연산자를 사용해 강제적으로 수행한다.</p>
<ol>
<li>(변환할타입) 변환할데이터</li>
<li>변환할타입 (변환할데이터)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">double</span> result1 = num1 / num2;   <span class="comment">//0 (int형 데이터끼리의 산술 연산에 대한 결과값은 int형이다.)</span></span><br><span class="line"><span class="keyword">double</span> result2 = (<span class="keyword">double</span>) num1 / num2;  <span class="comment">//0.25</span></span><br><span class="line"><span class="keyword">double</span> result3 = <span class="keyword">double</span> (num1) / num2;  <span class="comment">//0.25</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="연산자"><a href="#연산자" class="headerlink" title="연산자"></a>연산자</h3><h4 id="산술-연산자"><a href="#산술-연산자" class="headerlink" title="산술 연산자"></a>산술 연산자</h4><p>+, -, *, /, %</p>
<h4 id="대입-연산자"><a href="#대입-연산자" class="headerlink" title="대입 연산자"></a>대입 연산자</h4><p>=, +=, -=, *=, /=, %=</p>
<h4 id="증감-연산자"><a href="#증감-연산자" class="headerlink" title="증감 연산자"></a>증감 연산자</h4><p>++x, x++, –x, x–</p>
<h4 id="비교-연산자"><a href="#비교-연산자" class="headerlink" title="비교 연산자"></a>비교 연산자</h4><p>==, !=, &gt;, &lt;, &gt;=, &lt;=</p>
<h4 id="논리-연산자"><a href="#논리-연산자" class="headerlink" title="논리 연산자"></a>논리 연산자</h4><p>&amp;&amp;, ||, !</p>
<h4 id="비트-연산자"><a href="#비트-연산자" class="headerlink" title="비트 연산자"></a>비트 연산자</h4><p>&amp;, |, ^(xor, 같으면 0 다르면 1), ~(not, 1의 보수), &lt;&lt;(left shift), &gt;&gt;(right shift, 부호를 유지한다.)</p>
<h4 id="기타-연산자"><a href="#기타-연산자" class="headerlink" title="기타 연산자"></a>기타 연산자</h4><ul>
<li>삼항 연산자 : 조건식 ? 반환값1 : 반환값2</li>
<li>쉼표 연산자 : 둘 이상의 변수를 동시에 선언하거나 둘 이상의 인수를 함수로 전달할 때</li>
<li>sizeof : 피연산자의 크기를 바이트 단위로 반환한다.<h4 id="C-연산자"><a href="#C-연산자" class="headerlink" title="C++ 연산자"></a>C++ 연산자</h4></li>
<li><p>범위 지정 연산자(::)</p>
<ol>
<li>::식별자</li>
<li>클래스이름::식별자</li>
<li>네임스페이스::식별자</li>
<li>열거체::식별자</li>
</ol>
</li>
<li><p>멤버 포인터 연산자</p>
<ol>
<li>클래스타입의객체.*멤버이름</li>
<li>클래스타입객체의포인터-&gt;*멤버이름</li>
</ol>
</li>
<li><p>typreid 연산자 : 객체의 타입 반환. 런타임에 객체의 타입을 결정하거나, 템플릿에서 템플릿 매개변수의 타입을 결정할 떄 사용한다.</p>
<p>  <code>typeid(표현식)</code></p>
</li>
</ul>
<hr>
<h3 id="제어문"><a href="#제어문" class="headerlink" title="제어문"></a>제어문</h3><h4 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h4><ul>
<li><p>if 문</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (조건식)</span><br><span class="line">&#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>if/else 문</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (조건식)</span><br><span class="line">&#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>if/else if/ else 문</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (조건식)</span><br><span class="line">&#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>switch 문</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(조건 값)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 값<span class="number">1</span>:</span><br><span class="line">        명령문;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 값<span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> 값<span class="number">3</span>:</span><br><span class="line">        명령문;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        명령문;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h4><ul>
<li><p>while 문</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(조건식</span><br><span class="line">&#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>do/while 문</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125; <span class="keyword">while</span> (조건식);</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 문</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (초기식; 조건식; 증감식)</span><br><span class="line">&#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>범위 기반 for 문 : 표현식 안에 포함되어 있는 모든 값에 대해 한 번씩 루프를 실행해준다. 배열을 자동으로 인식하며, 컨테이너 클래스에서 많이 사용된다.</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> element : arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;element&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="기타-제어문"><a href="#기타-제어문" class="headerlink" title="기타 제어문"></a>기타 제어문</h4><p>반복문의 흐름을 사용자가 직접 제어하도록 도와준다.</p>
<ul>
<li>continue 문 : 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고 바로 다음 조건식의 판단으로 넘어가게 해준다.</li>
<li>break 문 : 루프 내에서 사용하여 해당 반복문을 종료시킨다.</li>
<li>goto 문 : 프로그램의 흐름을 지정된 레이블로 무조건 변경시킨다. 프로그램의 흐름을 복잡하게 만들어 디버깅 이외에 거의 사용되지 않는다.</li>
</ul>
<hr>
<h3 id="배열과-포인터"><a href="#배열과-포인터" class="headerlink" title="배열과 포인터"></a>배열과 포인터</h3><p>배열(array)은 같은 타입의 변수들로 이루어진 유한 집합이다. 배열을 구성하는 각각의 값을 element, 배열에서의 위치를 가리키는 숫자를 index 라고한다.</p>
<h4 id="1차원-배열"><a href="#1차원-배열" class="headerlink" title="1차원 배열"></a>1차원 배열</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//배열 선언 : 타입 배열이름[배열길이];</span></span><br><span class="line"><span class="keyword">int</span> grade[<span class="number">3</span>];</span><br><span class="line">grade[<span class="number">0</span>] = <span class="number">85</span>;</span><br><span class="line">grade[<span class="number">0</span>] = <span class="number">90</span>;</span><br><span class="line">grade[<span class="number">0</span>] = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age[<span class="number">3</span>] = &#123;<span class="number">20</span>, <span class="number">32</span>&#125;;  <span class="comment">//초기화되지 못한 나머지는 0으로 초기화된다.</span></span><br><span class="line"><span class="keyword">int</span> age2[<span class="number">3</span>] = &#123;&#125;;   <span class="comment">//전부 0으로 초기화된다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> grade2[<span class="number">3</span>];</span><br><span class="line">grade2 = grade; <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//배열의 길이를 입력하지 않으면 초기화 리스트에 맞춰 자동으로 길이가 설정된다.</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>선언만 하고 초기화하지 않으면, 모든 배열 요소가 쓰레기값으로 채워진다.</li>
<li>배열의 이름은 배열의 첫 번째 요소와 같은 주소를 가리킨다. (grade = grade[0]의 주소)</li>
<li>C++ 컴파일러는 배열의 길이 등을 일일이 검사하여 오류를 출력해 주지 않는다. 존재하지 않는 인덱스에 접근해도 오류가 없으니 주의해야 한다.</li>
<li>배열이 차지하는 메모리의 크기 = 배열의 길이 X sizeof(타입)</li>
<li>배열의 길이 = sizeof(배열 이름) / sizeof(배열 이름[0])</li>
</ul>
<h4 id="다차원-배열"><a href="#다차원-배열" class="headerlink" title="다차원 배열"></a>다차원 배열</h4><p>2차원 이상의 배열로, 배열 요소로 또 다른 배열을 가지는 배열이다.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//선언</span></span><br><span class="line">타입 배열이름[행의길이][열의길이];</span><br><span class="line"></span><br><span class="line"><span class="comment">//초기화 방식1</span></span><br><span class="line"><span class="keyword">int</span> arr1[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, ... , <span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//초기화 방식2</span></span><br><span class="line"><span class="keyword">int</span> arr2[<span class="number">3</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, ...&#125;,</span><br><span class="line">    &#123;<span class="number">6</span>, <span class="number">7</span>, ...&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//초기화 방식3</span></span><br><span class="line"><span class="keyword">int</span> arr3[<span class="number">3</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">70</span>, <span class="number">80</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 열의 길이</span></span><br><span class="line"><span class="keyword">int</span> arr_col_len = <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p>
<p>2차원 배열에서 열의 길이는 생략할 수 있지만, 행의 길이는 반드시 명시해야 한다. 행의 길이 생략시 컴파일 오류 발생.</p>
<h4 id="포인터-개념"><a href="#포인터-개념" class="headerlink" title="포인터 개념"></a>포인터 개념</h4><ul>
<li>주소값 : 데이터가 저장된 메모리의 시작 주소를 의미한다.</li>
<li><p>포인터 : 메모리의 주소값을 저장하는 변수로, 포인터 변수라고도 부른다.</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;   <span class="comment">// 변수의 선언</span></span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;n; <span class="comment">// 포인터의 선언</span></span><br><span class="line"><span class="keyword">int</span> **pptr = &amp;ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ptr1, ptr2;    <span class="comment">//ptr1은 int형 포인터, ptr2는 int형 변수로 선언된다.</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>주소 연산자(&amp;) : 변수 이름 앞에 사용하여, 변수의 주소값을 반환한다.</p>
</li>
<li>참조 연산자(*) : 포인터의 이름이나 주소 앞에 사용하여, 포인터에 저장된 주소에 저장되어 있는 값을 반환한다.</li>
<li>포인터의 타입은 참조 연산자를 통해 값을 참조할 때, 참조할 메모리의 크기를 알려주는 역할을 한다.</li>
</ul>
<h4 id="포인터-연산"><a href="#포인터-연산" class="headerlink" title="포인터 연산"></a>포인터 연산</h4><p>&lt;포인터 연산 규칙&gt;</p>
<ol>
<li>포인터끼리의 덧셈, 곱셈, 나눗셈은 아무런 의미가 없다.</li>
<li>포인터끼리의 뺄셈은 두 포인터 사이의 상대적 거리를 나타낸다.</li>
<li>포인터에 정수를 더하거나 뺄 수는 있지만, 실수와의 연산은 허용하지 않는다.</li>
<li>포인터끼리 대입하거나 비교할 수 있다.</li>
</ol>
<ul>
<li>포인터 연산 후 각각의 포인터가 가리키는 주소의 증가, 감소 폭은 포인터가 가리키는 변수의 타입에 따라 다르다. (예를들어, int형 포인터는 4바이트씩 증가, 감소한다.)</li>
<li><p>배열의 이름은 값을 변경할 수 없는 상수라는 점을 제외하면 포인터와 같다. 배열의 이름은 해당 배열의 첫 번째 요소의 주소와 같다. (arr가 포인터 또는 배열일 때, <code>arr[n] == *(arr+n)</code>)</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr = arr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ptr[<span class="number">0</span>]&lt;&lt;<span class="string">", "</span>&lt;&lt;ptr[<span class="number">1</span>]&lt;&lt;<span class="string">", "</span>&lt;&lt;ptr[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//1, 2, 3</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(arr+<span class="number">0</span>)&lt;&lt;<span class="string">", "</span>&lt;&lt;*(arr+<span class="number">1</span>)&lt;&lt;<span class="string">", "</span>&lt;&lt;*(arr+<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//1, 2, 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(arr)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//12</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(ptr)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<p>  * 포인터를 이용한 크기 계산에서는 배열의 크기가 아닌 포인터 변수의 크기가 출력된다.</p>
</li>
<li>포인터 연산으로 배열의 크기를 넘어서는 접근을 해도 컴파일러 오류가 발생하지 않는다.</li>
</ul>
<h4 id="메모리-동적-할당"><a href="#메모리-동적-할당" class="headerlink" title="메모리 동적 할당"></a>메모리 동적 할당</h4><p>데이터 영역과 스택 영역에 할당되는 메모리는 컴파일 타임에 미리 결정된다. 하지만 힙 영역의 크기는 런 타임에 사용자가 직접 결정하게 되며, 런 타임에 메모리를 할당받는 것을 메모리 동작 할당이라고 한다.</p>
<p>포인터를 통해 런 타임에 메모리를 할당받아 포인터에 할당, 할당받은 메모리에 접근할 수 있다.</p>
<p>C++에서는 C언어의 라이브러리 함수를 통해서도 동적 할당 및 해제가 가능하지만 new, delete 연산자를 통한 방법이 효과적이다.</p>
<ul>
<li>new 연산자 : 자유 기억 공간(free store)라는 메모리 공간(memory pool)에 객체를 위한 메모리를 할당받는다. new를 통해 할당받은 메모리는 이름이 없어 해당 포인터로만 접근이 가능하며, 사용할 수 있는 메모리가 부족해 메모리를 만들지 못한 경우 널 포인터를 반환한다.</li>
<li>delete 연산자 : 사용하지 않는 메모리를 다시 메모리 공간에 돌려준다.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///타입* 포인터이름 = new 타입;</span></span><br><span class="line"><span class="keyword">int</span> *ptr_int = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*ptr_int = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> *ptr_double = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">*ptr_double = <span class="number">100.123</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> ptr_int;</span><br><span class="line"><span class="keyword">delete</span> ptr_double;</span><br></pre></td></tr></table></figure>
<!-- ---
### 문자열

#### 문자열


#### string 클래스


#### string 메소드


---
### 구조체

#### 구조체 기본


#### 구조체 활용


#### 공용체와 열거체


---
### 함수

#### 함수의 정의


#### 인수 전달 방법


#### 재귀 호출


#### 함수 포인터


#### 참조자


#### 디폴트 인수


#### 함수 오버로딩


#### 인라인 함수 -->
            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">TAGGED IN</span><br>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/C/">C++</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/09/05/알고리즘-알고리즘-공부-시작/" data-tooltip="[알고리즘]알고리즘 공부 시작!" aria-label="NEXT: [알고리즘]알고리즘 공부 시작!">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
                <li class="post-action">
                    <a class="post-action-btn btn btn--default" href="#disqus_thread">
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 Ujoy. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--disabled">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">PREVIOUS</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2019/09/05/알고리즘-알고리즘-공부-시작/" data-tooltip="[알고리즘]알고리즘 공부 시작!" aria-label="NEXT: [알고리즘]알고리즘 공부 시작!">
                
                    <span class="hide-xs hide-sm text-small icon-mr">NEXT</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
                <li class="post-action">
                    <a class="post-action-btn btn btn--default" href="#disqus_thread">
                        <i class="fa fa-comment"></i>
                    </a>
                </li>
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Back to top">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/egg.jpg" alt="Author&#39;s picture">
        
            <h4 id="about-card-name">Ujoy</h4>
        
            <div id="about-card-bio"><p>기억력을 믿지 못해 블로그를 시작했다.</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>student</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br>
                대한민국
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-dbd16rvloemmuxdzniplmnxxvwoz24eya9wol0b7vvmlokgqsjivmb8dnscy.min.js"></script>
<!--SCRIPTS END-->

    
        <script>
             var disqus_config = function () {
                 this.page.url = 'https://Ujoy7851.github.io/2019/09/09/C/';
                 
                    this.page.identifier = '2019/09/09/C/';
                 
             };
            (function() {
                var d = document, s = d.createElement('script');
                var disqus_shortname = 'UJoyBlog';
                s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);
            })();
        </script>
    



    </body>
</html>
