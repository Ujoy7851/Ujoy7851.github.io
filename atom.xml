<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>UJoyBlog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://Ujoy7851.github.io/"/>
  <updated>2019-11-24T11:56:47.649Z</updated>
  <id>https://Ujoy7851.github.io/</id>
  
  <author>
    <name>Ujoy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Java]String 문자열</title>
    <link href="https://Ujoy7851.github.io/2019/11/24/Java-String/"/>
    <id>https://Ujoy7851.github.io/2019/11/24/Java-String/</id>
    <published>2019-11-24T11:53:18.000Z</published>
    <updated>2019-11-24T11:56:47.649Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>자바에서 문자열에 해당하는 자료형</p><p>String 인스턴스는 한 번 생성되면 그 값을 읽기만 할 수 있고, 변경할 수 없다. 자바에서 <code>+</code> 연산자를 이용해 문자열 결합을 수행하면 기존 문자열이 변경되는 것이 아니라 새로운 String 인스턴스가 생성된다.</p><h3 id="문자열-선언-및-할당"><a href="#문자열-선언-및-할당" class="headerlink" title="문자열 선언 및 할당"></a>문자열 선언 및 할당</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"Happy Java"</span>;</span><br><span class="line">String b = <span class="string">"a"</span>;</span><br><span class="line">String c = <span class="string">"123"</span>;</span><br><span class="line"></span><br><span class="line">String a = <span class="keyword">new</span> String(<span class="string">"Happy Java"</span>);</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br><span class="line">String c = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br></pre></td></tr></table></figure><p>첫번째 방식을 사용하는게 가독성도 좋고 컴파일 시 최적화에 도움을 준다.</p><p>String은 리터럴로 표기가 가능하지만 primitive 자료형이 아닌 참조형타입이다.</p><h3 id="대표적인-String-메소드"><a href="#대표적인-String-메소드" class="headerlink" title="대표적인 String 메소드"></a>대표적인 String 메소드</h3><table><thead><tr><th>메소드</th><th>설명</th></tr></thead><tbody><tr><td>char charAt(int index)</td><td>해당 문자열의 특정 인덱스에 해당하는 문자를 반환함.</td></tr><tr><td>int compareTo(String str)</td><td>해당 문자열을 인수로 전달된 문자열과 사전 편찬 순으로 비교함. 대소문자를 구분함. 두 문자열이 같으면 0, 해당 문자열이 인수로 전달된 문자열보다 작으면 음수, 크면 양수를 반환함.</td></tr><tr><td>int compareToIgnoreCase(String str)</td><td>해당 문자열을 인수로 전달된 문자열과 대소문자를 구분하지 않고 사전 편찬 순으로 비교함.</td></tr><tr><td>String concat(String str)</td><td>해당 문자열의 뒤에 인수로 전달된 문자열을 추가한 새로운 문자열을 반환함.</td></tr><tr><td>int indexOf(int ch)</td><td>int indexOf(String str)</td><td>해당 문자열에서 특정 문자나 문자열이 처음으로 등장하는 위치의 인덱스를 반환함.</td></tr><tr><td>int indexOf(int ch, int fromIndex), int indexOf(String str, int fromIndex)</td><td>해당 문자열에서 특정 문자나 문자열이 전달된 인덱스 이후에 처음으로 등장하는 위치의 인덱스를 반환함. 포함되어 있지 않는 경우 -1을 반환함. 대소문자를 구분함.</td></tr><tr><td>int lastIndexOf(int ch)</td><td>해당 문자열에서 특정 문자가 마지막으로 등장하는 위치의 인덱스를 반환함.</td></tr><tr><td>int lastIndexOf(int ch, int fromIndex)</td><td>해당 문자열에서 특정 문자가 전달된 인덱스 이후에 마지막으로 등장하는 위치의 인덱스를 반환함.</td></tr><tr><td>String[] split(String regex)</td><td>해당 문자열을 전달된 정규 표현식(regular expression)에 따라 나눠서 반환함.</td></tr><tr><td>String substring(int beginIndex)</td><td>해당 문자열의 전달된 인덱스부터 끝까지를 새로운 문자열로 반환함.</td></tr><tr><td>String substring(int begin, int end)</td><td>해당 문자열의 전달된 시작 인덱스부터 마지막 인덱스까지를 새로운 문자열로 반환함.</td></tr><tr><td>String toLowerCase()</td><td>해당 문자열의 모든 문자를 소문자로 변환함.</td></tr><tr><td>String toUpperCase()</td><td>해당 문자열의 모든 문자를 대문자로 변환함.</td></tr><tr><td>String trim()</td><td>해당 문자열의 맨 앞과 맨 뒤에 포함된 모든 공백 문자를 제거함.</td></tr><tr><td>length()</td><td>해당 문자열의 길이를 반환함.</td></tr><tr><td>isEmpty()</td><td>해당 문자열의 길이가 0이면 true를 반환하고, 아니면 false를 반환함.</td></tr><tr><td>equals()</td><td>해당 문자열이 인수와 동일한 값을 가지고 있는지를 비교하여 결과값을 리턴함. 같으면 true, 다르면 false</td></tr><tr><td>String replaceAll()</td><td>문자열 중 특정 문자를 다른 문자로 바꿔줌</td></tr></tbody></table><ul><li><p>String 객체의 값을 비교할때는 <code>equals</code>를 사용해야 한다. <code>==</code>를 사용할 경우 참조값을 비교해 동일한 객체인지 판별하기 때문에 값이 같아도 false를 반환한다.</p></li><li><p>for each문 String에 적용하는 법</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> c : <span class="string">"xyz"</span>)  <span class="comment">//이렇게 할 경우 compile error 발생</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">"xyz"</span>;</span><br><span class="line">str.chars().forEachOrdered(i -&gt; System.out.print((<span class="keyword">char</span>)i));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : <span class="string">"xyz"</span>.split(<span class="string">""</span>)) &#123;</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> ch: <span class="string">"xyz"</span>.toCharArray()) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;자바 String 문자열 정리&lt;br&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://Ujoy7851.github.io/categories/Programming/"/>
    
    
      <category term="Java" scheme="https://Ujoy7851.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>[알고리즘]정렬 알고리즘</title>
    <link href="https://Ujoy7851.github.io/2019/11/24/sort/"/>
    <id>https://Ujoy7851.github.io/2019/11/24/sort/</id>
    <published>2019-11-24T11:49:11.000Z</published>
    <updated>2019-11-24T11:56:43.721Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h2 id="정렬"><a href="#정렬" class="headerlink" title="정렬"></a>정렬</h2><p>정렬은 주어진 데이터를 숫자의 순서나 어휘의 순서대로 나열하는 것이다. 데이터의 정렬은 빠른 탐색을 위한 것으로 데이터가 정렬되어 있는 경우 이진탐색을 할 수 있다.</p><p>이진탐색은 logn의 성능을 보이는데 이는 43억개의 정렬된 자료에서 어떤 값을 찾을 때 최악의 비교횟수가 32인 속도이다.</p><p>현재 비교정렬 알고리즘은 시간복잡도를 O(nlgn) 이하로 줄일 수 없다고 증명되었다.</p><h2 id="대표적인-정렬의-종류"><a href="#대표적인-정렬의-종류" class="headerlink" title="대표적인 정렬의 종류"></a>대표적인 정렬의 종류</h2><table><thead><tr><th>종류</th><th>시간복잡도</th></tr></thead><tbody><tr><td>버블정렬</td><td>O(n²)</td></tr><tr><td>선택정렬</td><td>O(n²)</td></tr><tr><td>삽입정렬</td><td>O(n²)</td></tr><tr><td>병합정렬</td><td>O(nlogn)</td></tr><tr><td>힙정렬</td><td>O(nlogn)</td></tr><tr><td>퀵정렬</td><td>O(nlogn)</td></tr></tbody></table><h2 id="O-n²-정렬"><a href="#O-n²-정렬" class="headerlink" title="O(n²) 정렬"></a>O(n²) 정렬</h2><h3 id="버블정렬-Bubble-Sort"><a href="#버블정렬-Bubble-Sort" class="headerlink" title="버블정렬 (Bubble Sort)"></a>버블정렬 (Bubble Sort)</h3><p> <img src="https://upload.wikimedia.org/wikipedia/commons/0/06/Bubble-sort.gif" alt="bubble sort gif에 대한 이미지 검색결과"></p><ul><li>매번 연속된 두개의 인덱스를 비교하며 정한 기준의 값을 뒤로 넘기는 방식을 반복한다. 오름차순으로 정렬하고자 할 경우, 비교시마다 큰 값이 뒤로 이동해 1바퀴 돌 시 가장 큰 값이 맨 뒤에 저장된다.</li><li>시간복잡도가 거의 모든 상황에서 최악인 정렬방법. 이미 정렬된 자료일 경우는 최선의 성능</li><li><p>공간복잡도는 O(n)이다.</p><h3 id="선택정렬-Selection-Sort"><a href="#선택정렬-Selection-Sort" class="headerlink" title="선택정렬 (Selection Sort)"></a>선택정렬 (Selection Sort)</h3><p><img src="https://hudi.kr/wp-content/uploads/2018/02/selectionsort.gif" alt="selection sort gif에 대한 이미지 검색결과"></p></li><li>단순한 정렬 방법으로 모든 요소를 훑어서 가장 작은 데이터를 골라내는 방식을 n번 반복하며 복잡도는 O(n²)이다.</li><li>교환 과정이 n을 넘지 않으므로 교환비용이 많이 드는 상황에서 유용하다.</li><li>하나의 배열에서 정렬을 진행하므로 공간복잡도는 O(n)이다.</li></ul><h3 id="삽입정렬-Insertion-Sort"><a href="#삽입정렬-Insertion-Sort" class="headerlink" title="삽입정렬 (Insertion Sort)"></a>삽입정렬 (Insertion Sort)</h3><p> <img src="https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif" alt="insertion sort gif에 대한 이미지 검색결과"></p><ul><li>모든 요소에 대해 앞에서부터 차례대로 이미 정렬된 배열과 비교하여 정렬된 배열 내 자신의 위치를 찾아 삽입</li><li>평균적으로 버블정렬, 선택정렬보다 빠르나 자료구조에 따라 밀어내는데 오랜 시간이 걸린다.</li><li>이미 정렬된 자료에 삽입/삭제하는 경우에 오버헤드가 적어 최선의 알고리즘</li><li>배열의 크기가 작을때 상당히 효율적이어서 배열의 크기가 클때는 O(nlng) 알고리즘을 쓰다가 삽입정렬로 전환하기도 한다.</li></ul><h2 id="O-nlgn-정렬"><a href="#O-nlgn-정렬" class="headerlink" title="O(nlgn) 정렬"></a>O(nlgn) 정렬</h2><h3 id="병합정렬-Merge-Sort"><a href="#병합정렬-Merge-Sort" class="headerlink" title="병합정렬(Merge Sort)"></a>병합정렬(Merge Sort)</h3><p> <img src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" alt="merge sort gif에 대한 이미지 검색결과"></p><ul><li>원소의 개수가 1 또는 0이 될 때까지 두 부분으로 쪼개서 자른 순서의 역순으로 크기를 비교해 병합하는 분할 정복 알고리즘이다. 병합된 부분은 이미 정렬되어 있으므로 전부 비교하지 않아도 제자리를 찾을 수 있다.</li><li>정렬할 데이터 크기만한 메모리가 더 필요하다.</li><li>퀵정렬, 힙정렬에 비해 성능이 떨어지지만 Stable sort(기존 데이터의 순서를 유지)이라는 장점이 있다.</li><li><p>정렬된 두 배열의 정렬된 합집합을 구할 때 병합정렬 알고리즘의 마지막 단계를 이용할 수 있다.</p><h3 id="힙정렬-Heap-Sort"><a href="#힙정렬-Heap-Sort" class="headerlink" title="힙정렬(Heap Sort)"></a>힙정렬(Heap Sort)</h3><p><img src="https://thumbs.gfycat.com/WarlikeChiefBeagle-max-1mb.gif" alt="heap sort gif에 대한 이미지 검색결과"></p></li><li>원소들을 전부 힙에 삽입한 뒤 힙의 루트의 있는 값이 최소값(최댓값)을 가지므로 루트를 출력하고 힙에서 제거한다. 힙이 빌 때까지 이를 반복한다.</li><li><p>일반적인 경우 퀵 정렬이 빠르지만 최악의 경우 O(n²)의 성능을 가지는 퀵 정렬에 비해 항상 O(nlgn)의 일정한 성능을 발휘한다.</p><h3 id="퀵정렬-Quick-Sort"><a href="#퀵정렬-Quick-Sort" class="headerlink" title="퀵정렬(Quick Sort)"></a>퀵정렬(Quick Sort)</h3><p><img src="https://dojo.stuycs.org/resources/_images/quicksort.gif" alt="관련 이미지"></p></li><li>적절한 원소 하나를 기준(피벗, pivot)으로 잡고 그보다 작은 것을 앞으로 빼내고 그 뒤에 피벗을 옮겨 피벗보다 작은 것, 큰 것으로 나눈다. 그리고 각각에서 다시 피벗을 잡고 정렬해서 각각의 크기가 0이나 1이 될 때까지 정렬한다.</li><li>평균적인 상황에서 최고의 성능을 나타낸다.</li><li>C, C++, Java 등 거의 모든 언어에서 제공하는 정렬함수에서 퀵 정렬 또는 퀵 정렬의 변형 알고리즘을 사용한다.</li><li>피벗으로 어떤 값을 잡는지에 따라 효율이 달라진다. 최악의 경우 시간복잡도가 O(n²)가 되는데, 피벗을 최솟값이나 최댓값으로 계속해서 잡게 되는 경우에 그렇다. 랜덤으로 피벗값을 잡는 것이 대표적인 방법이지만 O(n²)일수도 있으므로 순수한 퀵 소트보다는 다른 정렬 알고리즘과 섞는 하이브리드 퀵 소트를 쓴다.</li></ul><h2 id="하이브리드-정렬"><a href="#하이브리드-정렬" class="headerlink" title="하이브리드 정렬"></a>하이브리드 정렬</h2><h3 id="인트로-정렬-Intro-sort"><a href="#인트로-정렬-Intro-sort" class="headerlink" title="인트로 정렬 (Intro sort)"></a>인트로 정렬 (Intro sort)</h3><ul><li>퀵정렬 + 힙정렬</li><li>퀵 정렬을 기본으로 하지만 재귀 깊이가 깊어지는 경우 힙정렬을 사용한다.</li></ul><h3 id="팀-정렬-Tim-sort"><a href="#팀-정렬-Tim-sort" class="headerlink" title="팀 정렬 (Tim sort)"></a>팀 정렬 (Tim sort)</h3><ul><li>병합정렬 + 삽입정렬</li><li>병합정렬은 원소의 개수가 적을 때 오버헤드가 발생하기 때문에 파티션 크기가 특정 값(보통 16 또는 32) 이하일 때 삽입정렬을 사용한다.</li></ul><h2 id="각-언어에서-사용하는-정렬-알고리즘"><a href="#각-언어에서-사용하는-정렬-알고리즘" class="headerlink" title="각 언어에서 사용하는 정렬 알고리즘"></a>각 언어에서 사용하는 정렬 알고리즘</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul><li>Arrays.sort : 퀵 정렬</li><li>Collections.sort : 합병정렬 (퀵 정렬이 stable하지 않고 일정한 효율 O(nlgn)을 보장하지 않아서)</li></ul><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>파이썬은 팀정렬(Tim sort)를 사용한다. 이는 stale하지 않기 때문이다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;정렬 알고리즘 정리&lt;br&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://Ujoy7851.github.io/categories/Programming/"/>
    
    
      <category term="Algorithm" scheme="https://Ujoy7851.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>dynamic programming</title>
    <link href="https://Ujoy7851.github.io/2019/10/22/dynamic-programming/"/>
    <id>https://Ujoy7851.github.io/2019/10/22/dynamic-programming/</id>
    <published>2019-10-22T12:17:45.000Z</published>
    <updated>2019-11-02T03:43:37.608Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h3 id="다이나믹-프로그래밍-DP"><a href="#다이나믹-프로그래밍-DP" class="headerlink" title="다이나믹 프로그래밍 (DP)"></a>다이나믹 프로그래밍 (DP)</h3><ul><li>큰 문제를 작은 문제로 나눠서 푸는 알고리즘</li><li>다이나믹 프로그래밍은 작게 나눈 문제끼리 중복되지만 분할정복은 그렇지 않다는 점에서 차이가 있다.</li></ul><h3 id="DP로-해결가능한-문제의-속성"><a href="#DP로-해결가능한-문제의-속성" class="headerlink" title="DP로 해결가능한 문제의 속성"></a>DP로 해결가능한 문제의 속성</h3><ol><li>Overlapping Subproblem<ul><li>큰 문제와 작은 문제를 같은 방법으로 풀 수 있다.</li><li>문제를 작은 문제로 쪼갤 수 있다.</li><li>예: 피보나치 수열 Fn = Fn-1 + Fn-2</li></ul></li><li>Optimal Substructure<ul><li>문제의 정답을 작은 문제의 정답에서 구할 수 있다.</li><li>문제의 크기에 상관없이 어떤 한 문제의 정답은 일정하다.</li></ul></li></ol><ul><li>Optimal Substructure를 만족하기 때문에, 같은 문제는 구할 때마다 정답이 같으므로, 다이나믹 프로그래밍에서 각 문제는 한 번만 푼다.</li><li>한 번 구한 정답은 배열에 저장해놓는 식으로 메모하듯이 구현하는 것을 Memoization이라고 한다.</li><li>점화식을 만들어 풀이</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//memoization을 적용한 피보나치 수를 구하는 함수</span></span><br><span class="line"><span class="comment">//Top-down</span></span><br><span class="line"><span class="comment">//O(N)</span></span><br><span class="line"><span class="keyword">int</span> memo[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(memo[n] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[n];</span><br><span class="line">        &#125;</span><br><span class="line">        memo[n] = fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="구현-방식"><a href="#구현-방식" class="headerlink" title="구현 방식"></a>구현 방식</h3><ol><li>Top-down<ul><li>재귀로 푸는 방식</li></ul></li><li>Bottom-up<ul><li>작은 문제부터 차례대로 푸는 방식</li><li>반복문으로 구현<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">int</span> d[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    d[<span class="number">0</span>];</span><br><span class="line">    d[<span class="number">1</span>];</span><br><span class="line">    fof(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">        d[i] = d[i<span class="number">-1</span>] + d[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li>재귀로 푸는 경우 스택오버플로우를 조심해야하나 구현이 잘된 경우 발생하지 않음</li><li>둘 중에 편한 방식 하나를 골라 연습</li></ul><h3 id="관련-연습문제"><a href="#관련-연습문제" class="headerlink" title="관련 연습문제"></a>관련 연습문제</h3><ul><li>1로 만들기 (1463)</li><li>2xn 타일링 (11726)</li><li>2xn 타일링2 (11727)</li><li>1, 2, 3 더하기 (9095)</li><li>카드 구매하기 (11052)</li><li>카드 구매하기2 (16194)</li><li>1, 2, 3 더하기 5 (15990)</li><li>쉬운 계단 수 (10844)</li><li>이친수 (2193)</li><li>가장 긴 증가하는 부분 수열 (11053)</li><li>가장 긴 증가하는 부분 수열 4 (14002)</li><li>연속합 (1912)</li><li>제곱수의 합 (1699)</li><li>합분해 (2225)</li><li>…</li><li>1, 2, 3 더하기 3 (15988)</li><li>RGB거리 (1149)</li><li>동물원 (1309)</li><li>오르막 수 (11057)</li><li>스티커 (9465)</li><li>포도주 시식 (2156)</li><li>정수 삼각형 (1932)</li><li>가장 큰 증가 부분 수열 (11055)</li><li>가장 긴 감소하는 부분 수열 (11722)</li><li>가장 긴 바이토닉 부분 수열 (11054)</li><li>연속합 2 (13398)</li><li>타일 채우기 (2133)</li><li>…</li><li>동물원 (1309)</li><li>RGB거리 2 (17404)</li><li>합분해 (2225)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;다이나믹 프로그래밍이란?&lt;br&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://Ujoy7851.github.io/categories/Programming/"/>
    
    
      <category term="Algorithm" scheme="https://Ujoy7851.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>math</title>
    <link href="https://Ujoy7851.github.io/2019/10/06/math/"/>
    <id>https://Ujoy7851.github.io/2019/10/06/math/</id>
    <published>2019-10-06T13:18:00.000Z</published>
    <updated>2019-10-22T12:17:05.333Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h3 id="나머지-연산"><a href="#나머지-연산" class="headerlink" title="나머지 연산"></a>나머지 연산</h3><ul><li>(A+B) mod M = ((A mod M) + (B mod M)) mod M</li><li>(A<em>B) mod M = ((A mod M) </em> (B mod M)) mod M</li><li>나누기의 경우 성립안함</li><li>뺄셈의 경우 먼저 mod 연산을 한 결과가 음수일 수 있음을 주의</li><li>(A-B) mod M = ((A mod M) - (B mod M) + M) mod M</li></ul><h3 id="최대공약수-GCD"><a href="#최대공약수-GCD" class="headerlink" title="최대공약수 (GCD)"></a>최대공약수 (GCD)</h3><ul><li>두 수의 공통된 약수 중 가장 큰 정수</li><li><p>가장 간단하게 구하는 방법: 2부터 min(A, B)까지 모든 정수로 나누어 보기 (O(N)의 시간복잡도)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; min(A, B); i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a % i == <span class="number">0</span> &amp;&amp; b % i == <span class="number">0</span>) &#123;</span><br><span class="line">        g = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>유클리드 호제법을 사용하면 빠르게 구할 수 있음</p><ul><li>a, b를 나눈 나머지 r</li><li>GCD(a, b) = GCD(b, r)</li><li>r이 0이면 그 떄의 b가 최대공약수<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//재귀함수 사용한 방법</span></span><br><span class="line"><span class="comment">//a &lt; b라고 해서 a, b를 swap 시킬 필요없음</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> b;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//반복문을 사용한 방법</span></span><br><span class="line"> <span class="comment">//O(lgN)의 시간복잡도</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span>(b != <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">int</span> r = a%b;</span><br><span class="line">         a = b;</span><br><span class="line">         b = r;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> a;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="최소공배수-LCM"><a href="#최소공배수-LCM" class="headerlink" title="최소공배수 (LCM)"></a>최소공배수 (LCM)</h3><ul><li>두 수의 공통된 배수 중 가장 작은 정수</li><li>GCD를 이용해 구할 수 있음</li><li>A <em> B = GCD </em> LCM</li></ul><h3 id="소수"><a href="#소수" class="headerlink" title="소수"></a>소수</h3><ul><li>약수가 1과 자기 자신 밖에 없는 수</li><li><p>관련 알고리즘1 : 어떤 수 N이 소수인지 아닌지 판별</p><ul><li><p>2부터 N-1까지 나누어서 확인</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2부터 N/2까지 나누어서 확인 (약수 중 가장 큰 수는 N/2보다 작거나 같기 때문)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n/<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2부터 루트N까지 나누어서 확인 (N = a * b 일 때, a &lt;= 루트N, b &gt;= 루트N 이기 때문)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(루트N)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">prime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>관련 알고리즘2 : N이하의 소수를 찾는 방법</p><ul><li>1부터 N까지 소수인지 아닌지 하나씩 확인, O(N*루트N)</li><li>에라토스테네스의 체 (가장 빠른 방법)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[<span class="number">100</span>]; <span class="comment">//소수 저장</span></span><br><span class="line"><span class="keyword">int</span> pn = <span class="number">0</span>; <span class="comment">//소수의 개수</span></span><br><span class="line"><span class="keyword">bool</span> check[<span class="number">101</span>];    <span class="comment">//지워졌으면 true</span></span><br><span class="line"><span class="keyword">int</span> n= <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(check[i] == <span class="literal">false</span>)&#123;</span><br><span class="line">        prime[pn++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i*i; j &lt;= n; j += i) &#123;</span><br><span class="line">            check[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//안쪽의 for문에서 i*i가 i=1,000,000일 경우 int의 표현범위인 21억을 넘기 때문에 문제가 있을 수도 있어 i*2, i+i와 같이 바꾸는 것이 좋음</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>골드바흐의 추측</p><ul><li>2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능하다.</li><li>위 문장에 3을 더하면 5보다 큰 모든 짝수는 세 소수의 합으로 표현 가능하다.</li><li>10^18 이하에서는 참으로 증명됨</li><li>N = a + b (a, b는 소수)를 구할 때, 에라토스테네스의 체를 사용해 범위 내의 모든 소수(a)를 구한 뒤, N - b가 소수인지 판별하는 방식으로 구할 수 있다. N - b가 소수인지 아닌지는 check배열로 검사하면 된다.</li></ul></li></ul><h3 id="팩토리얼"><a href="#팩토리얼" class="headerlink" title="팩토리얼"></a>팩토리얼</h3><ul><li>N! = 1 <em> 2 </em> … * N</li><li>10! = 3628800</li></ul><h3 id="관련-연습문제"><a href="#관련-연습문제" class="headerlink" title="관련 연습문제"></a>관련 연습문제</h3><ul><li>GCD 합 (9613)</li><li>숨바꼭질 6 (17087)</li><li>2진수 8진수 (1373)</li><li>8진수 2진수 (1212)</li><li>-2진수 (2089)</li><li>골드바흐 파티션 (17103)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;알고리즘 풀이에 도움이 되는 수학 정리&lt;br&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://Ujoy7851.github.io/categories/Programming/"/>
    
    
      <category term="Algorithm" scheme="https://Ujoy7851.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>[알고리즘]자료구조_큐</title>
    <link href="https://Ujoy7851.github.io/2019/10/01/queue/"/>
    <id>https://Ujoy7851.github.io/2019/10/01/queue/</id>
    <published>2019-10-01T13:33:50.000Z</published>
    <updated>2019-10-06T12:51:03.794Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h3 id="큐-Queue"><a href="#큐-Queue" class="headerlink" title="큐 (Queue)"></a>큐 (Queue)</h3><ul><li>한쪽 끝에서만 자료를 넣고 다른 한쪽 끝에서만 뺄 수 있는 자료구조 (FIFO)</li><li>push, pop, front, back, empty, size</li><li>BFS 알고리즘에 사용</li><li><p>일차원 배열 하나로 구현 가능</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">queue</span>[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//큐에 포함된 내용은 [begin, end)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>[end] = data;</span><br><span class="line">  end += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>[begin] = <span class="number">0</span>;</span><br><span class="line">    begin += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>구현된 라이브러리 사용 가능<ul><li>C++: STL의 queue</li><li>Java: java.util.Queue</li></ul></li></ul></li></ul><h4 id="큐-응용문제"><a href="#큐-응용문제" class="headerlink" title="큐 응용문제"></a>큐 응용문제</h4><ul><li>조세퍼스 문제 (1158)</li></ul><h3 id="덱-Deque-Double-ended-queue"><a href="#덱-Deque-Double-ended-queue" class="headerlink" title="덱 (Deque, Double-ended queue)"></a>덱 (Deque, Double-ended queue)</h3><ul><li>양 끝에서만 자료를 넣고 뺼 수 있는 자료구조</li><li>사용하는 연산에 따라 스택으로도 큐로도 사용 가능</li><li>push_front, push_back, pop_front, pop_back, front, back</li></ul><h4 id="덱-응용문제"><a href="#덱-응용문제" class="headerlink" title="덱 응용문제"></a>덱 응용문제</h4><ul><li>덱 (10866)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;큐와 덱&lt;br&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://Ujoy7851.github.io/categories/Programming/"/>
    
    
      <category term="Algorithm" scheme="https://Ujoy7851.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>[알고리즘]자료구조_스택</title>
    <link href="https://Ujoy7851.github.io/2019/09/10/stack/"/>
    <id>https://Ujoy7851.github.io/2019/09/10/stack/</id>
    <published>2019-09-10T05:58:36.000Z</published>
    <updated>2019-10-23T11:05:03.003Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h3 id="스택"><a href="#스택" class="headerlink" title="스택"></a>스택</h3><ul><li>한쪽 끝에서만 자료를 넣고 뺄 수 있는 자료구조 (LIFO)</li><li>push, pop, empty, top</li><li><p>일차원 배열 하나로 구현 가능</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>[size] = data;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>[size - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    size -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>구현된 라이브러리 사용</p><ul><li>C++: std::stack</li><li>Java: Stack</li></ul></li></ul><h4 id="응용문제"><a href="#응용문제" class="headerlink" title="응용문제"></a>응용문제</h4><ul><li>단어 뒤집기 (9093)</li><li>괄호 (9012)</li><li>스택 수열 (1874)</li><li>에디터 (1406) (링크드 리스트로 풀이 가능)</li><li>단어 뒤집기2 (17413)</li><li>쇠막대기 (10799)</li></ul><p>** c++ 입력 관련 정리</p><ul><li><p>getline() : 띄어쓰기/공백을 포함한 문자열을 입력 받을 수 있음</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br></pre></td></tr></table></figure></li><li><p>cin.ignore() : <code>cin &gt;&gt; n</code>으로 정수를 입력받고 바로 <code>getline(cin, str)</code>로 문자열을 입력받고자 할 경우 정수값을 입력한 뒤 누른 엔터가 버퍼에 남아있다가 str에 저장된다. 이럴 때 <code>cin.ignore()</code>로 입력 버퍼의 내용을 제거시켜주면 된다.</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="comment">//cin은 띄어쓰기, 엔터, 탭을 기준으로 입력값을 나누고, 이런 문자들이 나오면 무시하기 때문에 버퍼에 그대로 남아있다. 하지만 getline()의 경우 delim을 지정해주지 않으면 엔터('\n')를 기준으로 입력을 받아들인다.</span></span><br><span class="line"><span class="built_in">cin</span>.ignore();</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br></pre></td></tr></table></figure></li><li><p>cin.get() : char 하나 입력 받을 수 있음</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">cin</span>.get(str, <span class="number">256</span>);</span><br></pre></td></tr></table></figure></li><li><p>cin &gt;&gt; str : cin으로 string도 입력받을 수 있음 (띄어쓰기 전까지 입력받음)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;</span><br></pre></td></tr></table></figure><p>(<code>cout &lt;&lt; str</code> 처럼 cout으로 string을 출력할 수는 없음)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c : str)&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>문자열은 크게 2가지 형태로 입력가능. C에서와 같이 char str[] 형태로 받는 방법과 <string>헤더파일의 string 클래스를 이용하는 방법. 주의, strlen 함수는 O(n), size 함수는 O(1)이다.</string></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;스택을 이용한 문제 해결 방법&lt;br&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://Ujoy7851.github.io/categories/Programming/"/>
    
    
      <category term="Algorithm" scheme="https://Ujoy7851.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>C++</title>
    <link href="https://Ujoy7851.github.io/2019/09/09/C/"/>
    <id>https://Ujoy7851.github.io/2019/09/09/C/</id>
    <published>2019-09-09T09:07:15.000Z</published>
    <updated>2019-09-10T06:14:00.588Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h2 id="1-C-개요"><a href="#1-C-개요" class="headerlink" title="1. C++ 개요"></a>1. C++ 개요</h2><h4 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h4><p>C언어의 절차지향적 언어의 특징과 클래스를 사용하는 객체 지향적 언어의 특징을 가졌다. 동시에 템플릿으로 대변되는 일반화 프로그래밍 방식의 언어이다.</p><p>C언어를 기초로 삼아 만들었기 때문에, C 표준 라이브러리를 사용할 수 있다.</p><h4 id="C-에서-소스-파일로부터-실행-파일을-생성하는-순서"><a href="#C-에서-소스-파일로부터-실행-파일을-생성하는-순서" class="headerlink" title="C++에서 소스 파일로부터 실행 파일을 생성하는 순서"></a>C++에서 소스 파일로부터 실행 파일을 생성하는 순서</h4><p><img src="http://tcpschool.com/lectures/img_c_programming.png" alt></p><ul><li>소스 파일의 작성 : .cpp 확장자로 된 소스 파일 작성</li><li>선행처리 : #로 시작하는 선행처리 지시문의 처리 작업</li><li>컴파일 : 기계어로 변환, 오브젝트 파일 생성(.o)</li><li>링크 : 운영체제와의 인터페이스를 담당하는 시동 코드(start-up code)와 오브젝트 파일, 라이브러리 파일 등을 합쳐 하나의 실행 파일 생성(.exe)</li></ul><h4 id="include-문"><a href="#include-문" class="headerlink" title="#include 문"></a>#include 문</h4><p>외부에 선언된 함수나 상수를 사용하기 위해서 헤더 파일의 내용을 현재 파일에 포함할 때 사용한다. C++에서는 헤더파일의 확장자를 사용하지 않는다. 기존 C언어 헤어 파일의 앞에 c를 추가하여 C++ 스타일의 헤더 파일로 변환하기도 한다.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br></pre></td></tr></table></figure></p><h4 id="define-문"><a href="#define-문" class="headerlink" title="#define 문"></a>#define 문</h4><p>함수나 상수를 단순화해주는 매크로 정의</p><h4 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h4><p>이름이 기억되는 영역을 뜻하며, 이름에 대한 충돌을 방지해주는 방법을 제공한다.</p><p>C++ 프로그램에서 표준 구성 요소인 클래스, 함수, 변수 등은 std라는 이름 공간에 저장되어 있으며 사용을 위해 std::를 붙어 해당 정의가 std라는 네임스페이스에 있다는 것을 컴파일러에게 알려주어야 한다.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"hi!"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>네임스페이스에 속한 정의를 간단하게 사용하려면 다음 명령문을 추가해 네임스페이스 이름을 붙이지 않고 사용 가능하다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><h4 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a>iostream</h4><p>C++의 표준 입출력 클래스를 정의하고 있는 헤더파일이다. C++에서는 cout 객체가 출력 작업을, cin 객체가 입력 작업을 수행한다. C언어처럼 printf(), scanf() 함수로도 입출력 작업 수행 가능하다. C++ 표준 입출력 객체는 입출력 데이터의 타입을 자동으로 변환시켜준다.</p><p>(scanf/printf가 cin/cout보다 빠르다.)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"나이를 입력하세요."</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;age;</span><br></pre></td></tr></table></figure><ul><li>&lt;&lt;(산입 연산자) : 출력할 데이터를 출력 스트림에 삽입</li><li>>&gt;(추출 연산자) : 사용자가 입력한 데이터를 입력 스트림에서 추출해 오른쪽 변수에 저장</li></ul><hr><h2 id="2-타입"><a href="#2-타입" class="headerlink" title="2. 타입"></a>2. 타입</h2><h4 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h4><p>변수란 데이터를 저장하기 위해 프로그램에 의해 이름을 할당받은 메모리 공간을 의미한다. 저장된 값은 변경될 수 있다.</p><p><strong>변수 생성 규칙</strong></p><ul><li>변수의 이름은 영문자(대소문자), 숫자, 언더스코어(_)로만 구성한다.</li><li>변수의 이름은 숫자로 시작될 수 없다.</li><li>변수의 이름 사이에는 공백을 포함할 수 없다.</li><li>변수의 이름으로 C++에서 미리 정의된 키워드(keyword)는 사용할 수 없다.</li><li>변수 이름의 길이에는 제한이 없다.</li><li>대소문자는 구분된다.</li></ul><p>변수를 선언한 뒤 초기화하지 않으면 해당 메모리 공간에는 쓰레기값이 들어있다. 또한 다른 타입의 데이터를 저장할 경우 저장한 데이터에 변형이 일어날 수 있다.</p><h4 id="상수"><a href="#상수" class="headerlink" title="상수"></a>상수</h4><p>변수처럼 데이터를 저장할 수 있는 메모리 공간을 의미하지만 프로그램이 실행되는 동안 메모리에 저장된 데이터를 변경할 수 없다. 상수 표현 방식에 따라 리터럴 상수와 심볼릭 상수로 나뉜다.</p><ul><li><p>리터럴 상수(literal constant) : 변수와 달리 메모리 공간을 가리키는 이름을 가지고 있지 않다. 타입에 따라 정수형, 실수형, 문자형 리터럴 상수로 구분할 수 있다.</p><ul><li><p>정수형 : 10진수, 8진수(0으로 시작), 16진수(0x로 시작)로 표현할 수 있다. 여러 가지 진법으로 표현된 정수형 상수의 출력을 위해 cout 객체는 dec, hex, oct 조정자를 제공한다. 정수형 리터럴 상수는 데이터의 값이 너무 커서 int형으로 저장할 수 없거나, 접미사를 사용해 해당 상수의 타입을 직접 명시하는 경우를 제외하고 모두 int형으로 저장된다.</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  a  =  <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"숫자 10을 10진수로 표현하면 "</span>&lt;&lt;a&lt;&lt;<span class="string">"이며, "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;oct;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"숫자 10을 8진수로 표현하면 "</span>&lt;&lt;a&lt;&lt;<span class="string">"이며, "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;hex;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"숫자 10을 16진수로 표현하면 "</span>&lt;&lt;a&lt;&lt;<span class="string">" 입니다."</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><table><thead><tr><th>접미사</th><th>타입</th></tr></thead><tbody><tr><td>기본설정</td><td>(signed) int</td></tr><tr><td>u 또는 U</td><td>unsigned int</td></tr><tr><td>l 또는 L</td><td>(signed) long</td></tr><tr><td>ul 또는 uL 또는 Ul 또는 UL</td><td>unsigned long형</td></tr><tr><td>long long 또는 u11 또는 U11 또는 uLL 또는 ULL</td><td>unsigned long long형 (C++11부터 제공)</td></tr></tbody></table><ul><li>실수형 : 실수형 리터럴 상수는 모두 double형으로 저장되며 부동 소수점 방식으로 저장된다. 접미사를 추가하여 저장되는 타입을 직접 명시할 수도 있다.</li></ul><table><thead><tr><th>접미사</th><th>타입</th></tr></thead><tbody><tr><td>f 또는 F</td><td>float</td></tr><tr><td>기본 설정</td><td>double</td></tr><tr><td>l 또는 L</td><td>long double</td></tr></tbody></table><ul><li>포인터 : nullptr 키워드를 사용해 널 포인터를 표현할 수 있다. nullptr 키워드를 사용한 리터럴 상수의 타입은 포인터 타입이며, 정수형으로 변환할 수 없다. (0으로 포인터를 초기화해 널 포인터를 표현할 수 도 있지만 nullptr를 사용하는 것이 더 안전하다.)</li><li>이진 : 0B 또는 0b 접두사와 0과 1의 시퀀스를 가지고 이진 리터럴 상수를 표현할 수 있다.<ul><li>심볼릭 상수(symbolic constant) : 변수와 마찬가지로 이름을 가진 상수이다. 선언과 동시에 반드시 초기화해야 한다. 매크로를 이용하거나 const 키워드를 사용하여 선언할 수 있다. C++에서는 가급적 const 키워드를 사용하는 것이 좋다.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cosnt <span class="keyword">int</span> ages = <span class="number">30</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="기본-타입"><a href="#기본-타입" class="headerlink" title="기본 타입"></a>기본 타입</h4><p>타입은 해당 데이터가 메모리에 어떻게 저장되고, 어떻게 처리되어야 하는지를 명시적으로 알려준다. 기본 타입은 크게 정수형, 실수형, 문자형, bool형 타입으로 나뉜다.</p><ul><li>정수형 : 부호를 가진 소수 부분이 없는 수. unsigned는 부호를 나타내는 최상위 비트(MSB)까지 크기를 나타내는데 사용한다. 컴퓨터는 내부적으로 정수형 중에서도 int형의 데이터를 가장 빠르게 처리한다.</li></ul><table><thead><tr><th>정수형 타입</th><th>할당되는 메모리의 크기</th><th>데이터의 표현 범위</th></tr></thead><tbody><tr><td>(signed) short</td><td>2 바이트</td><td>-2^15 ~ (2^15 - 1)</td></tr><tr><td>unsigned short</td><td>2 바이트</td><td>0 ~ (2^16 - 1)</td></tr><tr><td>(signed) int</td><td>4 바이트</td><td>-2^31 ~ (2^31 - 1)</td></tr><tr><td>unsigned int</td><td>4 바이트</td><td>0 ~ (2^32 - 1)</td></tr><tr><td>(signed) long</td><td>4 바이트</td><td>-2^31 ~ (2^31 - 1)</td></tr><tr><td>unsigned long</td><td>4 바이트</td><td>0 ~ (2^32 - 1)</td></tr><tr><td>unsigned long long</td><td>8 바이트</td><td>0 ~ (2^64 - 1)</td></tr></tbody></table><ul><li>실수형 타입 : 정수보다 더 넓은 표현 범위를 가지지만 컴퓨터가 실수를 표현하는 방식은 오차가 발생할 수 밖에 없다. float형은 소수점 6자리, double형은 15자리까지 오차없이 표현 가능하다.</li></ul><table><thead><tr><th>실수형 타입</th><th>할당되는 메모리의 크기</th><th>데이터의 표현 범위</th></tr></thead><tbody><tr><td>float</td><td>4 바이트</td><td>(3.4 X 10-^38) ~ (3.4 X 10^38)</td></tr><tr><td>double</td><td>8 바이트</td><td>(1.7 X 10^-308) ~ (1.7 X 10^308)</td></tr><tr><td>long double</td><td>double형과 동일함.</td><td>double형과 동일함.</td></tr></tbody></table><ul><li>문자형 타입 : 문자형 데이터는 작은 정수나 문자 하나를 표현할 수 있다.</li></ul><table><thead><tr><th>문자형 타입</th><th>할당되는 메모리의 크기</th><th>데이터의 표현 범위</th></tr></thead><tbody><tr><td>(signed) char</td><td>1 바이트</td><td>2^-7 ~(2^7 - 1)</td></tr><tr><td>unsigned char</td><td>2 바이트</td><td>0 ~ 2^8</td></tr></tbody></table><ul><li>bool형 타입 : C++11부터 bool형 타입을 제공하며, true나 false 중 한 가지 값만을 가질 수 있다. 또한 어떤 값도 묵시적 타입 변환이 가능해 0인 값은 false로 나머지 값은 true로 자동 변환된다.</li></ul><p>* C++11부터 auto 키워드를 이용해 변수의 초깃값에 맞춰 변수의 타입이 자동으로 선언되게 할 수 있다.</p><h4 id="부동-소수점-수"><a href="#부동-소수점-수" class="headerlink" title="부동 소수점 수"></a>부동 소수점 수</h4><p>컴퓨터에서 실수를 2진수로 표현하기 위한 방식에는 고정 소수점 방식과 부동 소수점 방식이 있다.</p><ul><li><p>고정 소수점 방식(fixed point) : 실수는 정수부와 소수부로 나눌 수 있다. 고정 소수점 방식은 고정된 소수부 자릿수를 미리 정해 실수를 표현한다. 정수부와 소수부의 자릿수가 크지 않아 표현할 수 있는 범위가 적다.</p></li><li><p>부동 소수점 방식(floating point) : 실수를 가수부와 지수부로 나누어 표현한다.<br><code>±(1.가수부)×2^(지수부-127)</code>라는 수식을 이용해 매우 큰 실수까지도 표현 가능하며, 대부분의 시스템은 부동 소수점 방식을 택한다. 하지만 부동 소수점 방식에 의한 실수 표현에는 항상 오차가 존재한다.</p></li></ul><h4 id="타입-변환"><a href="#타입-변환" class="headerlink" title="타입 변환"></a>타입 변환</h4><p>다른 타입끼리의 연산은 피연산자들을 모두 같은 타입으로 만든 후에 수행된다. 다음과 같은 경우 자동으로 타입 변환이 수행된다.</p><ul><li>다른 타입끼리의 대입, 산수 연산 시</li><li>함수에 인수를 전달할 때</li></ul><p>표현 범위가 좁은 타입에서 표현 범위가 더 넓은 타입으로 변환 시에는 문제가 없지만 반대의 경우에서의 타입 변환은 데이터 손실이 발생한다.</p><p>&lt;타입 변환의 종류&gt;</p><ul><li><p>묵시적 타입 변환(자동) : 대입, 산술 연산에서 컴파일러가 자동으로 수행하는 타입 변환이다. 대입 연산에서는 연산자의 오른쪽에 존재하는 데이터의 타입이 왼쪽에 존재하는 데이터 타입으로 변환된다. 산술 연산 시에는 데이터의 손실이 최소화되는 방향으로 타입변환이 진행된다. (char형 → short형 → int형 → long형 → float형 → double형 → long double형)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = <span class="number">3.1415</span>;  <span class="comment">//num1에 저장된 값 : 3. narrowing cast. 데이터 손실</span></span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">8.3E12</span>;  <span class="comment">//num2에 저장된 값 : 2147483647, int형 저장 범위를 초과함</span></span><br><span class="line"><span class="keyword">double</span> num3 = <span class="number">5</span>;    <span class="comment">//num3에 저장된 값 : 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> result1 = <span class="number">5</span> + <span class="number">3.14</span>;   <span class="comment">//int형 데이터가 double형으로 자동 타입 변환됨.</span></span><br><span class="line"><span class="keyword">double</span> result2 = <span class="number">5.0f</span> + <span class="number">3.14</span>;   <span class="comment">//float형 데이터가 double형으로 자동 타입 변환됨.</span></span><br></pre></td></tr></table></figure><p>  *산술 연산 시 bool형 데이터인 true는 1로, false는 0으로 자동 타입 변환된다.</p></li><li><p>명시적 타입 변환(강제) : 사용자가 타입 캐스트 연산자를 사용해 강제적으로 수행한다.</p><ol><li>(변환할타입) 변환할데이터</li><li>변환할타입 (변환할데이터)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> num2 = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">double</span> result1 = num1 / num2;   <span class="comment">//0 (int형 데이터끼리의 산술 연산에 대한 결과값은 int형이다.)</span></span><br><span class="line"><span class="keyword">double</span> result2 = (<span class="keyword">double</span>) num1 / num2;  <span class="comment">//0.25</span></span><br><span class="line"><span class="keyword">double</span> result3 = <span class="keyword">double</span> (num1) / num2;  <span class="comment">//0.25</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><h2 id="3-연산자"><a href="#3-연산자" class="headerlink" title="3. 연산자"></a>3. 연산자</h2><h4 id="산술-연산자"><a href="#산술-연산자" class="headerlink" title="산술 연산자"></a>산술 연산자</h4><p>+, -, *, /, %</p><h4 id="대입-연산자"><a href="#대입-연산자" class="headerlink" title="대입 연산자"></a>대입 연산자</h4><p>=, +=, -=, *=, /=, %=</p><h4 id="증감-연산자"><a href="#증감-연산자" class="headerlink" title="증감 연산자"></a>증감 연산자</h4><p>++x, x++, –x, x–</p><h4 id="비교-연산자"><a href="#비교-연산자" class="headerlink" title="비교 연산자"></a>비교 연산자</h4><p>==, !=, &gt;, &lt;, &gt;=, &lt;=</p><h4 id="논리-연산자"><a href="#논리-연산자" class="headerlink" title="논리 연산자"></a>논리 연산자</h4><p>&amp;&amp;, ||, !</p><h4 id="비트-연산자"><a href="#비트-연산자" class="headerlink" title="비트 연산자"></a>비트 연산자</h4><p>&amp;, |, ^(xor, 같으면 0 다르면 1), ~(not, 1의 보수), &lt;&lt;(left shift), &gt;&gt;(right shift, 부호를 유지한다.)</p><h4 id="기타-연산자"><a href="#기타-연산자" class="headerlink" title="기타 연산자"></a>기타 연산자</h4><ul><li>삼항 연산자 : 조건식 ? 반환값1 : 반환값2</li><li>쉼표 연산자 : 둘 이상의 변수를 동시에 선언하거나 둘 이상의 인수를 함수로 전달할 때</li><li>sizeof : 피연산자의 크기를 바이트 단위로 반환한다.</li></ul><h4 id="C-연산자"><a href="#C-연산자" class="headerlink" title="C++ 연산자"></a>C++ 연산자</h4><ul><li><p>범위 지정 연산자(::)</p><ol><li>::식별자</li><li>클래스이름::식별자</li><li>네임스페이스::식별자</li><li>열거체::식별자</li></ol></li><li><p>멤버 포인터 연산자</p><ol><li>클래스타입의객체.*멤버이름</li><li>클래스타입객체의포인터-&gt;*멤버이름</li></ol></li><li><p>typreid 연산자 : 객체의 타입 반환. 런타임에 객체의 타입을 결정하거나, 템플릿에서 템플릿 매개변수의 타입을 결정할 떄 사용한다.</p><p>  <code>typeid(표현식)</code></p></li></ul><hr><h2 id="4-제어문"><a href="#4-제어문" class="headerlink" title="4. 제어문"></a>4. 제어문</h2><h4 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h4><ul><li><p>if 문</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (조건식)</span><br><span class="line">&#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>if/else 문</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (조건식)</span><br><span class="line">&#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>if/else if/ else 문</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (조건식)</span><br><span class="line">&#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>switch 문</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(조건 값)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 값<span class="number">1</span>:</span><br><span class="line">        명령문;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 값<span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> 값<span class="number">3</span>:</span><br><span class="line">        명령문;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        명령문;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a>반복문</h4><ul><li><p>while 문</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(조건식</span><br><span class="line">&#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>do/while 문</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125; <span class="keyword">while</span> (조건식);</span><br></pre></td></tr></table></figure></li><li><p>for 문</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (초기식; 조건식; 증감식)</span><br><span class="line">&#123;</span><br><span class="line">    명령문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>범위 기반 for 문 : 표현식 안에 포함되어 있는 모든 값에 대해 한 번씩 루프를 실행해준다. 배열을 자동으로 인식하며, 컨테이너 클래스에서 많이 사용된다.</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> element : arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;element&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="기타-제어문"><a href="#기타-제어문" class="headerlink" title="기타 제어문"></a>기타 제어문</h4><p>반복문의 흐름을 사용자가 직접 제어하도록 도와준다.</p><ul><li>continue 문 : 루프 내에서 사용하여 해당 루프의 나머지 부분을 건너뛰고 바로 다음 조건식의 판단으로 넘어가게 해준다.</li><li>break 문 : 루프 내에서 사용하여 해당 반복문을 종료시킨다.</li><li>goto 문 : 프로그램의 흐름을 지정된 레이블로 무조건 변경시킨다. 프로그램의 흐름을 복잡하게 만들어 디버깅 이외에 거의 사용되지 않는다.</li></ul><hr><h2 id="5-배열과-포인터"><a href="#5-배열과-포인터" class="headerlink" title="5. 배열과 포인터"></a>5. 배열과 포인터</h2><p>배열(array)은 같은 타입의 변수들로 이루어진 유한 집합이다. 배열을 구성하는 각각의 값을 element, 배열에서의 위치를 가리키는 숫자를 index 라고한다.</p><h4 id="1차원-배열"><a href="#1차원-배열" class="headerlink" title="1차원 배열"></a>1차원 배열</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//배열 선언 : 타입 배열이름[배열길이];</span></span><br><span class="line"><span class="keyword">int</span> grade[<span class="number">3</span>];</span><br><span class="line">grade[<span class="number">0</span>] = <span class="number">85</span>;</span><br><span class="line">grade[<span class="number">0</span>] = <span class="number">90</span>;</span><br><span class="line">grade[<span class="number">0</span>] = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> age[<span class="number">3</span>] = &#123;<span class="number">20</span>, <span class="number">32</span>&#125;;  <span class="comment">//초기화되지 못한 나머지는 0으로 초기화된다.</span></span><br><span class="line"><span class="keyword">int</span> age2[<span class="number">3</span>] = &#123;&#125;;   <span class="comment">//전부 0으로 초기화된다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> grade2[<span class="number">3</span>];</span><br><span class="line">grade2 = grade; <span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//배열의 길이를 입력하지 않으면 초기화 리스트에 맞춰 자동으로 길이가 설정된다.</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>선언만 하고 초기화하지 않으면, 모든 배열 요소가 쓰레기값으로 채워진다.</li><li>배열의 이름은 배열의 첫 번째 요소와 같은 주소를 가리킨다. (grade = grade[0]의 주소)</li><li>C++ 컴파일러는 배열의 길이 등을 일일이 검사하여 오류를 출력해 주지 않는다. 존재하지 않는 인덱스에 접근해도 오류가 없으니 주의해야 한다.</li><li>배열이 차지하는 메모리의 크기 = 배열의 길이 X sizeof(타입)</li><li>배열의 길이 = sizeof(배열 이름) / sizeof(배열 이름[0])</li></ul><h4 id="다차원-배열"><a href="#다차원-배열" class="headerlink" title="다차원 배열"></a>다차원 배열</h4><p>2차원 이상의 배열로, 배열 요소로 또 다른 배열을 가지는 배열이다.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//선언</span></span><br><span class="line">타입 배열이름[행의길이][열의길이];</span><br><span class="line"></span><br><span class="line"><span class="comment">//초기화 방식1</span></span><br><span class="line"><span class="keyword">int</span> arr1[<span class="number">3</span>][<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, ... , <span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//초기화 방식2</span></span><br><span class="line"><span class="keyword">int</span> arr2[<span class="number">3</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, ...&#125;,</span><br><span class="line">    &#123;<span class="number">6</span>, <span class="number">7</span>, ...&#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//초기화 방식3</span></span><br><span class="line"><span class="keyword">int</span> arr3[<span class="number">3</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">10</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#123;<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">70</span>, <span class="number">80</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 열의 길이</span></span><br><span class="line"><span class="keyword">int</span> arr_col_len = <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></p><p>2차원 배열에서 열의 길이는 생략할 수 있지만, 행의 길이는 반드시 명시해야 한다. 행의 길이 생략시 컴파일 오류 발생.</p><h4 id="포인터-개념"><a href="#포인터-개념" class="headerlink" title="포인터 개념"></a>포인터 개념</h4><ul><li>주소값 : 데이터가 저장된 메모리의 시작 주소를 의미한다.</li><li><p>포인터 : 메모리의 주소값을 저장하는 변수로, 포인터 변수라고도 부른다.</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;   <span class="comment">// 변수의 선언</span></span><br><span class="line"><span class="keyword">int</span> *ptr = &amp;n; <span class="comment">// 포인터의 선언</span></span><br><span class="line"><span class="keyword">int</span> **pptr = &amp;ptr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ptr1, ptr2;    <span class="comment">//ptr1은 int형 포인터, ptr2는 int형 변수로 선언된다.</span></span><br></pre></td></tr></table></figure></li><li><p>주소 연산자(&amp;) : 변수 이름 앞에 사용하여, 변수의 주소값을 반환한다.</p></li><li>참조 연산자(*) : 포인터의 이름이나 주소 앞에 사용하여, 포인터에 저장된 주소에 저장되어 있는 값을 반환한다.</li><li>포인터의 타입은 참조 연산자를 통해 값을 참조할 때, 참조할 메모리의 크기를 알려주는 역할을 한다.</li></ul><h4 id="포인터-연산"><a href="#포인터-연산" class="headerlink" title="포인터 연산"></a>포인터 연산</h4><p>&lt;포인터 연산 규칙&gt;</p><ol><li>포인터끼리의 덧셈, 곱셈, 나눗셈은 아무런 의미가 없다.</li><li>포인터끼리의 뺄셈은 두 포인터 사이의 상대적 거리를 나타낸다.</li><li>포인터에 정수를 더하거나 뺄 수는 있지만, 실수와의 연산은 허용하지 않는다.</li><li>포인터끼리 대입하거나 비교할 수 있다.</li></ol><ul><li>포인터 연산 후 각각의 포인터가 가리키는 주소의 증가, 감소 폭은 포인터가 가리키는 변수의 타입에 따라 다르다. (예를들어, int형 포인터는 4바이트씩 증가, 감소한다.)</li><li><p>배열의 이름은 값을 변경할 수 없는 상수라는 점을 제외하면 포인터와 같다. 배열의 이름은 해당 배열의 첫 번째 요소의 주소와 같다. (arr가 포인터 또는 배열일 때, <code>arr[n] == *(arr+n)</code>)</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr = arr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ptr[<span class="number">0</span>]&lt;&lt;<span class="string">", "</span>&lt;&lt;ptr[<span class="number">1</span>]&lt;&lt;<span class="string">", "</span>&lt;&lt;ptr[<span class="number">2</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//1, 2, 3</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(arr+<span class="number">0</span>)&lt;&lt;<span class="string">", "</span>&lt;&lt;*(arr+<span class="number">1</span>)&lt;&lt;<span class="string">", "</span>&lt;&lt;*(arr+<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//1, 2, 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(arr)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//12</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(ptr)&lt;&lt;<span class="built_in">endl</span>;    <span class="comment">//8</span></span><br></pre></td></tr></table></figure><p>  * 포인터를 이용한 크기 계산에서는 배열의 크기가 아닌 포인터 변수의 크기가 출력된다.</p></li><li>포인터 연산으로 배열의 크기를 넘어서는 접근을 해도 컴파일러 오류가 발생하지 않는다.</li></ul><h4 id="메모리-동적-할당"><a href="#메모리-동적-할당" class="headerlink" title="메모리 동적 할당"></a>메모리 동적 할당</h4><p>데이터 영역과 스택 영역에 할당되는 메모리는 컴파일 타임에 미리 결정된다. 하지만 힙 영역의 크기는 런 타임에 사용자가 직접 결정하게 되며, 런 타임에 메모리를 할당받는 것을 메모리 동작 할당이라고 한다.</p><p>포인터를 통해 런 타임에 메모리를 할당받아 포인터에 할당, 할당받은 메모리에 접근할 수 있다.</p><p>C++에서는 C언어의 라이브러리 함수를 통해서도 동적 할당 및 해제가 가능하지만 new, delete 연산자를 통한 방법이 효과적이다.</p><ul><li>new 연산자 : 자유 기억 공간(free store)라는 메모리 공간(memory pool)에 객체를 위한 메모리를 할당받는다. new를 통해 할당받은 메모리는 이름이 없어 해당 포인터로만 접근이 가능하며, 사용할 수 있는 메모리가 부족해 메모리를 만들지 못한 경우 널 포인터를 반환한다.</li><li>delete 연산자 : 사용하지 않는 메모리를 다시 메모리 공간에 돌려준다.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///타입* 포인터이름 = new 타입;</span></span><br><span class="line"><span class="keyword">int</span> *ptr_int = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*ptr_int = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> *ptr_double = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">*ptr_double = <span class="number">100.123</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> ptr_int;</span><br><span class="line"><span class="keyword">delete</span> ptr_double;</span><br></pre></td></tr></table></figure><hr><h2 id="6-문자열"><a href="#6-문자열" class="headerlink" title="6. 문자열"></a>6. 문자열</h2><p>일련의 연속된 문자들의 집합을 문자열이라고 한다. C++에서는 C언어 스타일과 string 클래스를 이용해 문자열을 생성할 수 있다.</p><h4 id="C언어-스타일-문자열"><a href="#C언어-스타일-문자열" class="headerlink" title="C언어 스타일 문자열"></a>C언어 스타일 문자열</h4><p>문자형 배열을 선언하면 이 배열이 곧 문자열 변수가 된다. 이 문자열 변수는 문자열의 끝에 널(NULL) 문자인 ‘\0’를 포함해줘야 한다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> address[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; address;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; address;</span><br></pre></td></tr></table></figure><p>위 코드에서 cin 객체는 띄어쓰기, 탭, 캐리지 리턴 문자를 모두 문자열의 끝으로 인식하기 때문에 띄어쓰기가 들어간 문자열을 입력할 수 없다. 띄어쓰기를 포함한 문자열을 입력받기 위해서는 cin 객체의 get() 메소드를 사용해야 한다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> address[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.get(address, SIZE).get();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; address;</span><br></pre></td></tr></table></figure><p>또한 배열의 크기를 초과하는 문자열을 입력하면 프로그램이 강제 종료되기 때문에 cin 객체의 ignore() 메소드를 사용해 원하는 크기의 입력만 받게 할 수 있다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">char</span> address[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>.get(address, SIZE).ignore(SIZE, <span class="string">'\n'</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; address;</span><br></pre></td></tr></table></figure><h4 id="string-클래스"><a href="#string-클래스" class="headerlink" title="string 클래스"></a>string 클래스</h4><h4 id="string-메소드"><a href="#string-메소드" class="headerlink" title="string 메소드"></a>string 메소드</h4><hr><h2 id="7-구조체"><a href="#7-구조체" class="headerlink" title="7. 구조체"></a>7. 구조체</h2><h4 id="구조체-기본"><a href="#구조체-기본" class="headerlink" title="구조체 기본"></a>구조체 기본</h4><h4 id="구조체-활용"><a href="#구조체-활용" class="headerlink" title="구조체 활용"></a>구조체 활용</h4><h4 id="공용체와-열거체"><a href="#공용체와-열거체" class="headerlink" title="공용체와 열거체"></a>공용체와 열거체</h4><hr><h2 id="8-함수"><a href="#8-함수" class="headerlink" title="8. 함수"></a>8. 함수</h2><h4 id="함수의-정의"><a href="#함수의-정의" class="headerlink" title="함수의 정의"></a>함수의 정의</h4><h4 id="인수-전달-방법"><a href="#인수-전달-방법" class="headerlink" title="인수 전달 방법"></a>인수 전달 방법</h4><h4 id="재귀-호출"><a href="#재귀-호출" class="headerlink" title="재귀 호출"></a>재귀 호출</h4><h4 id="함수-포인터"><a href="#함수-포인터" class="headerlink" title="함수 포인터"></a>함수 포인터</h4><h4 id="참조자"><a href="#참조자" class="headerlink" title="참조자"></a>참조자</h4><h4 id="디폴트-인수"><a href="#디폴트-인수" class="headerlink" title="디폴트 인수"></a>디폴트 인수</h4><h4 id="함수-오버로딩"><a href="#함수-오버로딩" class="headerlink" title="함수 오버로딩"></a>함수 오버로딩</h4><h4 id="인라인-함수"><a href="#인라인-함수" class="headerlink" title="인라인 함수"></a>인라인 함수</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;알고리즘 공부를 위한 C++ 기본 정리&lt;br&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://Ujoy7851.github.io/categories/Programming/"/>
    
    
      <category term="C++" scheme="https://Ujoy7851.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>[알고리즘]알고리즘 기초</title>
    <link href="https://Ujoy7851.github.io/2019/09/05/algorithm1/"/>
    <id>https://Ujoy7851.github.io/2019/09/05/algorithm1/</id>
    <published>2019-09-05T04:24:25.000Z</published>
    <updated>2019-10-22T12:09:03.664Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h3 id="시간-복잡도"><a href="#시간-복잡도" class="headerlink" title="시간 복잡도"></a>시간 복잡도</h3><ul><li>작성한 코드가 대략 얼마나 걸릴지 예상하는데 사용된다.</li><li>Big O Notation : 입력 크기 N에 대해서 (최악의 경우) 시간이 얼마나 걸릴지 나타내는 방법</li><li>문제를 풀기 전에 생각한 방법의 시간 복잡도를 계산해보고 제한 시간안에 수행될 경우에 구현하는 것이 좋다.</li><li>대략 입력의 크기가 1억일 때 1초정도 걸린다.</li><li>1초가 걸리는 입력의 크기<ul><li>O(1)</li><li>O(lgN)</li><li>O(N) : 1억</li><li>O(NlgN) : 5백만</li><li>O(N^2) : 1만</li><li>O(N^3) : 500</li><li>O(2^N) : 20</li><li>O(N!) : 10</li></ul></li></ul><hr><h3 id="메모리"><a href="#메모리" class="headerlink" title="메모리"></a>메모리</h3><ul><li>메모리 제한은 보통 넉넉하기 떄문에 걱정할 필요가 없다.</li><li>가장 많은 공간을 사용하는 것은 보통 배열이다.<ul><li>int a[10000][10000]; -&gt; 배열의 크기 = 400,000,000B = 381.469MB / 입력의 크기 N = 1억 (1초)이기 때문에 시간제한만 지키면 대부분 메모리는 크게 걱정할 필요가 없다.</li></ul></li></ul><hr><h3 id="입-출력"><a href="#입-출력" class="headerlink" title="입/출력"></a>입/출력</h3><ul><li>C : <code>scanf/printf</code> 사용</li><li><p>C++ : <code>scanf/printf</code>, <code>cin/cout</code> 사용</p><ul><li><p><code>scanf/printf</code>이 <code>cin/cout</code>보다 빠르지만 아래 내용을 추가하면 빨라진다.(이떄, <code>cin/cout</code>만 써야함)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ios_base::sync_with_studio(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">cout</span>.tie(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><ul><li>cout으로 ‘\n’을 출력하는게 endl보다 훨씬(10배가량) 빠르다.</li></ul></li></ul></li><li><p>Java : 입력은 <code>Scanner</code>, 출력은 <code>System.out</code> 사용</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc =  <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.println(<span class="string">"Hello world"</span>);</span><br></pre></td></tr></table></figure><ul><li>입력이 많은 경우 속도가 느려 <code>BufferedReader</code> 사용</li><li>출력이 많은 경우 <code>StringBuilder</code>를 사용해 한 문자열로 만들어서 출력을 한 번만 하거나 <code>BufferedWriter</code>를 사용한다.</li></ul></li></ul><hr><p>몇가지 예제를 통해 시간복잡도, 공간복잡도와 관련된 내용을 이해해보자.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;N; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 소스코드는 1부터 N까지 합을 계산하는 코드로 O(N)의 시간복잡도를 가진다.<br>같은 계산이라도 아래의 소스코드처럼 알고리즘을 바꿔주면 시간복잡도에서 엄청난 차이를 보인다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(N^2)</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;N; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;N; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) sum += j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//O(1)</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">sum = N*(N+<span class="number">1</span>)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>두 수를 T번 입력받아 합을 출력하는 경우에도 아래 소스코드처럼 입력을 다 받고 모아서 하나씩 출력하는 경우에는 T의 개수를 모를때 배열의 크기를 정하기도 어렵고, 입력이 큰 경우에 큰 크기의 배열을 필요하게 된다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>], b[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;t; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[i]+b[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>하지만 입력받고 바로 풀어서 출력하는 경우 훨씬 적은 양의 메모리를 사용한다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>** 입력 개수가 정해지지 않은 경우 EOF(End of File)까지 입력받으면 된다.<br>C : while(scanf(“%d %d”, &amp;a, &amp;d) == 2)<br>C++: while (cin &gt;&gt; a &gt;&gt; b)<br>Java : while(sc.hasNextInt())</p><hr><p><strong>추가로 Java 입출력과 관련된 내용을 정리하며 글을 마친다.</strong></p><p>BufferedReader/BufferedWriter는 Buffer에 있는 IO 클래스로 입출력시 버퍼를 이용해 데이터처리 효율성을 높다.</p><ul><li><p><code>BufferedReader</code></p><ul><li><p>Scanner를 통해 입력을 받으면 Space, Enter 모두 경계로 인식해 입력받은 데이터를 가공하기 편리하다. 하지만 BufferedReader는 Enter만 경계로 인식하고 받은 데이터가 String으로 고정되기 떄문에 형변환이 필요하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    String s = br.readLine();</span><br><span class="line">    <span class="keyword">int</span> i = Integer.parseInt(br.readLine);</span><br><span class="line">    br.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStrackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>readLine을 통해 입력받은 데이터는 Line 단위로만 나눠지기 때문에 공백 단위로 데이터를 가공하기 위해 다음 두가지 방법중 하나를 사용해 처리해주어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StringTokenizer를 이용한 방법</span></span><br><span class="line">StringTokenizer st = <span class="keyword">new</span> StringTokenizer(s);</span><br><span class="line"><span class="keyword">int</span> a = Integer.parseInt(st.nextToken());</span><br><span class="line"><span class="keyword">int</span> b = Integer.parseInt(st.nextToken());</span><br><span class="line"></span><br><span class="line"><span class="comment">//공백마다 데이터를 끊어 배열에 넣는 방법</span></span><br><span class="line">String array[] = s.split(<span class="string">" "</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>BufferedWriter</code></p><ul><li>역시 출력량이 많아지면 System.out.println()보다 속도가 빠르다.</li><li>BufferedWriter는 버퍼를 이용하기 떄문에 다 쓴 뒤에 반드시 flush()를 호출해 버퍼를 비워줘야 해주어야 한다. bw.write()에는 자동개행 기능이 없다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">String s = <span class="string">"abcd"</span>;</span><br><span class="line">bw.write(s + <span class="string">'\n'</span>);</span><br><span class="line">bw.write(<span class="string">"hello"</span>);</span><br><span class="line">bw.newLine();</span><br><span class="line">bw.write(<span class="string">"world"</span>);</span><br><span class="line">bw.flush();</span><br><span class="line">bw.close();</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;백준의 [알고리즘 기초] 강의를 들으며 알고리즘 공부 시작&lt;br&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://Ujoy7851.github.io/categories/Programming/"/>
    
    
      <category term="Algorithm" scheme="https://Ujoy7851.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Pseudocode</title>
    <link href="https://Ujoy7851.github.io/2019/08/29/Pseudocode/"/>
    <id>https://Ujoy7851.github.io/2019/08/29/Pseudocode/</id>
    <published>2019-08-29T14:58:53.000Z</published>
    <updated>2019-09-05T04:25:49.541Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h4 id="Pseudocode-의사코드란"><a href="#Pseudocode-의사코드란" class="headerlink" title="Pseudocode 의사코드란"></a>Pseudocode 의사코드란</h4><p>일반적인 언어로  코드를 흉내내어 알고리즘을 써놓은 코드로, 프로그램을 작성하기 전에 알고리즘의 모델을 대략적으로 모델링하는데 사용한다. 프로그래밍 언어처럼 엄밀한 문법을 따를 필요가 없다.</p><h4 id="수식표현"><a href="#수식표현" class="headerlink" title="수식표현"></a>수식표현</h4><ul><li>연산자는 일반적 수학 심볼 사용</li><li>배정문은 <code>&lt;-</code> 사용</li><li>동일 관계 비교 <code>=</code> 사용</li></ul><h4 id="함수선언"><a href="#함수선언" class="headerlink" title="함수선언"></a>함수선언</h4><p>Algorithm name(인수1, 인수2)</p><h4 id="구조적표현"><a href="#구조적표현" class="headerlink" title="구조적표현"></a>구조적표현</h4><ul><li>if … then … (else …)</li><li>while … do</li><li>repeat … until</li><li>loop … do</li><li>for … do</li><li>array: name[i], name[i, j]</li></ul><h4 id="함수표현"><a href="#함수표현" class="headerlink" title="함수표현"></a>함수표현</h4><ul><li>호출: 함수명(인수들)</li><li>반환: return value</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Psuedocode란?&lt;br&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://Ujoy7851.github.io/categories/Programming/"/>
    
    
      <category term="Programming" scheme="https://Ujoy7851.github.io/tags/Programming/"/>
    
  </entry>
  
  <entry>
    <title>[자료구조]배열, 구조체</title>
    <link href="https://Ujoy7851.github.io/2019/08/29/array/"/>
    <id>https://Ujoy7851.github.io/2019/08/29/array/</id>
    <published>2019-08-29T05:49:45.000Z</published>
    <updated>2019-10-22T12:18:25.618Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h4 id="배열-Array"><a href="#배열-Array" class="headerlink" title="배열 (Array)"></a>배열 (Array)</h4><ul><li>&lt;index, value&gt; 쌍으로 이루어진 데이터들의 집합</li><li>같은 종류의 데이터가 순차적으로 저장됨</li><li>인덱스는 배열의 시작점으로부터 값이 저장된 상대적 위치를 나타냄<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c언어 배열</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;     <span class="comment">// &#123;&#125;를 사용한 초기화는 선언 시에만 가능</span></span><br><span class="line"><span class="keyword">int</span> arr2[<span class="number">10</span>] = &#123;<span class="number">0</span>,&#125;;        <span class="comment">// 모든 요소를 0으로 초기화</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>] = <span class="string">"hello"</span>;    <span class="comment">// 배열 선언과 동시에 초기화헤야 함</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="구조체-Struct"><a href="#구조체-Struct" class="headerlink" title="구조체 (Struct)"></a>구조체 (Struct)</h4><ul><li>타입이 다른  데이터들의 그룹화<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C언어 구조체</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span>         <span class="comment">// 구조체 정의</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span>       <span class="comment">// 구조체 변수 선언</span></span><br><span class="line"><span class="built_in">strcpy</span>(person.name, <span class="string">"joy"</span>);</span><br><span class="line">person.age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> salary;</span><br><span class="line">&#125; p1;                   <span class="comment">// 구조체를 정의하는 동시에 변수 p1 선언, p1은 전역 변수</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">struct</span> <span class="params">(Person)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> salary;</span><br><span class="line">&#125; Person;              <span class="comment">// typedef를 사용해 변수 선언시 struct 생략 가능</span></span><br><span class="line">                       <span class="comment">// 구조체의 이름 생략 가능</span></span><br><span class="line"></span><br><span class="line">Person p1;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;배열, 구조체&lt;br&gt;
    
    </summary>
    
      <category term="Programming" scheme="https://Ujoy7851.github.io/categories/Programming/"/>
    
    
      <category term="DS" scheme="https://Ujoy7851.github.io/tags/DS/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js_1</title>
    <link href="https://Ujoy7851.github.io/2019/05/14/Vue-js-1/"/>
    <id>https://Ujoy7851.github.io/2019/05/14/Vue-js-1/</id>
    <published>2019-05-14T04:32:56.000Z</published>
    <updated>2019-08-29T05:56:53.505Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h2 id="Vue-js란-무엇인가"><a href="#Vue-js란-무엇인가" class="headerlink" title="Vue.js란 무엇인가?"></a>Vue.js란 무엇인가?</h2><h4 id="Vue-js란"><a href="#Vue-js란" class="headerlink" title="Vue.js란"></a>Vue.js란</h4><ul><li>웹 페이지 화면을 개발하기 위한 프런트엔트 프레임워크</li><li>뷰의 코어 라이브러리는 라이브러리 역할 뿐만 아니라 프레임워크 역할도 할 수 있는 점진적인 프레임워크</li><li>다른 프레임워크 (Angular, React)와 비교해 가볍고 빠름</li><li>배우기 쉽고 성능이 좋음</li></ul><p><code>프레임워크</code>: 개발 생산성을 높이기 위해 일정한 틀과 규칙에 따라 개발하도록 미리 구조를 정의해놓은 도구</p><p><code>라이브러리</code>: 자주 사용되는 기능들을 모아 재활용할 수 있도록 정리한 기술 모음집</p><h4 id="Vue-js-특징"><a href="#Vue-js-특징" class="headerlink" title="Vue.js 특징"></a>Vue.js 특징</h4><ol><li>MVVM 패턴의 ‘View Model’에 해당하는 화면단 라이브러리 (DOM Listener + Data Binding)</li></ol><ul><li>DOM Listener - DOM의 변경 내역에 대해 즉각적으로 반응하여 특정 로직을 수행</li><li>Data Binding - View에 표시되는 내용과 모델의 데이터를 동기화</li><li>예) 버튼을 클릭하면 돔 리스너에서 클릭 감지 -&gt; 버튼과 관련된 로직의 처리 -&gt; 결과에 해당하는 데이터를 모델에서 데이터바인딩으로 가져와 화면에 나타냄</li></ul><ol start="2"><li>컴포넌트 기반 프레임워크</li></ol><ul><li>컴포넌트를 조합하여 화면 구성</li><li>코드의 재사용을 높이고 HTML 코드에서 화면의 구조를 직관적으로 파악 가능 </li></ul><ol start="3"><li>리액트와 앵귤러의 장점을 가진 프레임워크</li></ol><ul><li>앵귤러의 양방향 데이터 바인딩 - 화면에 표스되는 값과 프레임워크의 모델 데이터 값이 동기화되어 한쪽이 변경되면 다른 한쪽도 자동으로 변경</li><li>리액트의 단방향 데이터 흐름 - 컴포넌트 간에 데이터를 전달할 떄 항상 상위 컴포넌트에서 하위 컴포넌트 방향으로만 전달</li><li>리액트의 가상 돔 렌더링 - 특정 돔 요소를 축다하거나 삭제하는 변경이 일어날 때 화면 전체를 그리지 않고 프레임워크에서 정의한 방식에 따라 화면 갱신. 브라우저의 성능 부하가 줄어들어 속도가 빨라짐</li></ul><p><code>MVVM 패턴</code>: 마크업 언어나 GUI 코드를 비지니스 로직 또는 백엔드 로직과 분리하여 개발하는 소프트웨어 디자인 패턴. 즉, 프런트엔드의 화면 동작과 관련된 로직과 백엔드의 데이터 처리 로직을 분리하여 가독성을 높임</p><p><img src="https://documentation.devexpress.com/HelpResource.ashx?help=WPF&amp;document=img4922787.jpg" alt="MVVM"></p><ul><li>View - 사용자에게 보이는 화면</li><li>View Model - 뷰와 모델의 중간 영역.</li><li>Model - 서버에서 가져온 데이터를 자바스크립트 객체 형태로 저장</li></ul><hr><h2 id="Vue-js-개발환경-설정"><a href="#Vue-js-개발환경-설정" class="headerlink" title="Vue.js 개발환경 설정"></a>Vue.js 개발환경 설정</h2><p>뷰로 웹 앱을 개발하기 위한 환경을 구성하기 위해 다음 도구들을 설치</p><h4 id="크롬-브라우저"><a href="#크롬-브라우저" class="headerlink" title="크롬 브라우저"></a>크롬 브라우저</h4><p>크롬 브라우저는 웹 개발 시 편리한 기능을 제공하는 크롬 개발자 도구를 지원함</p><h4 id="텍스트-에디터"><a href="#텍스트-에디터" class="headerlink" title="텍스트 에디터"></a>텍스트 에디터</h4><p>책에서는 ‘atom’을 소개했으나, 기존에 사용하던 텍스트 에디터나 IDE 사용해도 괜찮음</p><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><ul><li>서버 사이드 자바스크립트로, 서버 측에서 실행되는 자바스크립트 실행 환경을 의미</li><li>vue cli로 뷰 프로젝트를 구성하고 프로토타이핑 할 때 사용됨</li><li>nodejs.org에서 다운로드 받은 후 <code>node -v</code>로 설치 확인</li></ul><h4 id="뷰-개발자-도구-Vue-js-devtools"><a href="#뷰-개발자-도구-Vue-js-devtools" class="headerlink" title="뷰 개발자 도구 (Vue.js devtools)"></a>뷰 개발자 도구 (Vue.js devtools)</h4><ul><li>뷰로 만든 웹 앱의 구조를 간편하게 디버깅하거나 분석할 수 있음</li><li>크롬, 파이어폭스, 사파리에서 모두 지원</li></ul><hr><h2 id="뷰-인스턴스"><a href="#뷰-인스턴스" class="headerlink" title="뷰 인스턴스"></a>뷰 인스턴스</h2><p>뷰 인스턴스는 뷰로 화면을 개발하기 위해 필수적으로 생성해야 하는 기본 단위</p><h4 id="뷰-인스턴스-생성"><a href="#뷰-인스턴스-생성" class="headerlink" title="뷰 인스턴스 생성"></a>뷰 인스턴스 생성</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>뷰 인스턴스 생성자는 뷰 라이브러리를 로딩하고 나면 접급할 수 있음</p><h4 id="뷰-인스턴스-옵션-속성"><a href="#뷰-인스턴스-옵션-속성" class="headerlink" title="뷰 인스턴스 옵션 속성"></a>뷰 인스턴스 옵션 속성</h4><p>뷰 인스턴스를 생성할 때 재정의할 data, el, template, methods 등의 속성을 의미</p><ul><li>template: 화면에 표시할 HTML, CSS 등의 마크업 요소를 정의</li><li>methods: 화면 로직 제어와 관계된 메서드를 정의. 마우스 클릭 이벤트 처리와 같이 화면의 전반적인 이벤트와 화면 동작과 관련된 로직 추가 가능</li></ul><p><code>예제코드</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;Vue Sample&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">            &#123;&#123;message&#125;&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;script src=&quot;http://cdn.jsdelivr.net/npm/vue@2.5.2/dis/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            new Vue(&#123;</span><br><span class="line">                el: &apos;#app&apos;,</span><br><span class="line">                data: &#123;</span><br><span class="line">                    message: &apos;Hello Vue.js!&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><ul><li>el 속성은 부로 만든 화면이 그려지는 시작점을 의미. 위 코드에서는 app이라는 아이디를 가진 돔 요소에 뷰 인스턴스가 그려짐. 이떄 선택자는 CSS 선택자 규칙과 동일</li></ul><h4 id="뷰-인스턴스-유효-범위"><a href="#뷰-인스턴스-유효-범위" class="headerlink" title="뷰 인스턴스 유효 범위"></a>뷰 인스턴스 유효 범위</h4><ul><li>뷰 인스터스를 생성하면 HTML의 특정 범위 내에서만 옵션 속성들이 적용됨</li><li>el 속성과 관계가 있음</li><li><p>new Vue()로 인스턴스를 생성하고 나서 화면에 인스턴스 옵션 속성을 적용하는 과정은 다음과 같음</p><p>  뷰 라이브러리 파일 로딩 -&gt; 인스턴스 객체 생성(옵션 속성 포함) -&gt; 특정 화면 요소에 인스턴스를 붙임 -&gt; 인스턴스 내용이 화면 요소로 변환 -&gt; 변환된 화면 요소를 사용자가 확인</p></li><li><p>위 예제 코드에서 el 속성에 인스턴스가 부착되고 나면 인스턴스에 정의한 data 속성이 el 속성에 지정한 화면 요소와 그 이하 레벨의 화면 요소에 적용되어 다음처럼 값이 치환됨</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&apos;app&apos;&gt;</span><br><span class="line">    Hello Vue.js!</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p>예제 코드의 일부가 아래처럼 변경된 경우 <div id="app">태그 바깥 범위에 있는 를 인식하지 못 하기 떄문에 치환되지 않고  그대로 출력됨</div></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&apos;app&apos;&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;&#123;message&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="뷰-인스턴스-라이프-사이클"><a href="#뷰-인스턴스-라이프-사이클" class="headerlink" title="뷰 인스턴스 라이프 사이클"></a>뷰 인스턴스 라이프 사이클</h4><p>인스턴스의 상태에 따라 호출할 수 있는 속성들을 라이프 사이클 속성이라고 하고 각 라이프 사이클 속성에서 실행되는 커스텀 로직을 라이프 사이클 훅이라고 함.</p><p><img src="https://www.google.co.kr/url?sa=i&amp;source=images&amp;cd=&amp;ved=2ahUKEwiRlqv986viAhUHi7wKHRwhBjUQjRx6BAgBEAU&amp;url=https%3A%2F%2Fm.blog.naver.com%2Fdmswldla91%2F221298888944&amp;psig=AOvVaw20OaJimfq8ymGxv5j6FPmO&amp;ust=1558503445418812" alt="뷰 라이프 사이클 다이어그램"></p><p>위 다이어그램에서 부착 -&gt; 갱신 구간은 데이터가 변경되는 경우에만 거치게 됨</p><ul><li><code>beforeCreate</code>: data, methods 속성이 아직 인스턴스에 정의되어 있지 않고, 돔과 같은 화면 요소에도 접근 불가</li><li><code>created</code>: data, methods 속성이 정의되어 this.data 또는 this.fetchData()와 같이 속성에 정의된 값에 접근하여 로직 실행 가능. 하지만 아직 인스턴스가 화면 요소에 부착되기 전이어서 template 속성에 정의된 돔 요소에 접근 불가. 서버에 데이터를 요청하여 받아오는 로직을 수행하기 좋음</li><li><code>beforeMount</code>: template 속성에 지정한 마크업 속성을 render() 함수로 변환한 후 el 속성에 지정한 화면 요소에 인스턴스를 부착하기 전에 호출됨. render() 함수 호출 직전의 로직을 추가하기 좋음 (render는 자바스크립트로 화면의 돔을 그리는 함수)</li><li><code>mounted</code>: el 속성에 지정한 화면 요소에 인스턴스가 부착되고 나서 호출됨. template 속성에 정의한 화면 요소에 접근할 수 있어 화면 요소를 제어하는 로직을 수행하기 좋음. 인스턴스가 부착되자마자 호출되기 때문에 하위 컴포넌트나 외부 라이브러리에 의해 추가된 화면 요소들이 최종 HTML 코드로 변환되는 시점과 다를 수 있음 ($nextTick() API를 활용해 HTML 코드로 최종 파싱될 때까지 기다린 후에 돔 제어 로직을 추가)</li><li><code>beforeUpdate</code>: 인스턴스가 화면 요소에 부착되고 나면 인스턴스에 정의한 속성들이 화면에 치환되는데 이 값은 뷰의 반응성을 제공하기 위해 $watch 속성으로 감시. 이를 데이터 관찰이라고 함. 관찰 중인 데이터가 변경되면 가상 돔으로 화면을 다시 그리기 전에 호출 됨. 변경 예정인 새 데이터의 값과 관련된 로직을 수행할 수 있음</li><li><code>updated</code>: 데이터 변경되고 나서 가상 돔으로 다시 화면을 그리고 나서 실행됨. 데이터 변경 후 화면 요소 제어와 관련된 로직 수행에 좋음. 이 단계 에서 데이터 값을 변경하면 무한 루프에 빠질 수 있어 computed, watch와 같은 속성을 사용해야 함. 데이터 값을 갱신하는 로직은 되도록 beforeUpdate에서 다루는 것이 좋음 (mounted와 마찬가지로 $nextTick()을 사용해 변환이 완료된 후에 로직을 추가)</li><li><code>beforeDestroy</code>: 인스턴스 파괴되기 직전에 호출. 아직 인스턴스에 접근 가능. 인스턴스의 데이터를 삭제하기 좋은 단계</li><li><code>destroyed</code>: 인스턴스가 파괴되고 나서 호출. 인스턴스에 정의한 모든 속성이 제거되고 하위에 선언한 인스턴스들도 모두 파괴됨</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;‘Vue.js 입문’ 포스팅 1&lt;br&gt;
    
    </summary>
    
      <category term="Vue.js" scheme="https://Ujoy7851.github.io/categories/Vue-js/"/>
    
    
      <category term="Vue.js" scheme="https://Ujoy7851.github.io/tags/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title>VS code에서 c/c++ 컴파일 환경설정하기 (Window)</title>
    <link href="https://Ujoy7851.github.io/2019/04/03/visual-studio-c/"/>
    <id>https://Ujoy7851.github.io/2019/04/03/visual-studio-c/</id>
    <published>2019-04-03T12:31:29.000Z</published>
    <updated>2019-04-03T15:12:41.853Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --></p><h4 id="1-MinGW-다운로드"><a href="#1-MinGW-다운로드" class="headerlink" title="1. MinGW 다운로드"></a>1. MinGW 다운로드</h4><p>링크: <a href="https://sourceforge.net/projects/mingw/" target="_blank" rel="noopener">https://sourceforge.net/projects/mingw/</a></p><p>MinGW 설치후 Installation Manager에서 아래 패키지 선택 후, Apply Changes</p><ul><li>mingw-developer-toolkit</li><li>mingw32-base</li><li>mingw32-gcc-g++</li><li>msys-base</li></ul><h4 id="2-환경변수-설정"><a href="#2-환경변수-설정" class="headerlink" title="2. 환경변수 설정"></a>2. 환경변수 설정</h4><p>제어판 - 시스템 및 보안 - 시스템 - 고급 시스템 설정 - 시스템 속성 - 고급 - 환경변수 - Path 변수에 C:\MinGW\bin 추가</p><h4 id="3-설치-확인"><a href="#3-설치-확인" class="headerlink" title="3. 설치 확인"></a>3. 설치 확인</h4><p>cmd를 켜서 gcc/g++ 컴파일러가 제대로 설치되었는지 확인</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc –v</span><br><span class="line">g++ –v</span><br></pre></td></tr></table></figure><h4 id="4-VS-code-컴파일-환경설정"><a href="#4-VS-code-컴파일-환경설정" class="headerlink" title="4. VS code 컴파일 환경설정"></a>4. VS code 컴파일 환경설정</h4><ul><li>VS code의 확장 마켓플레이스에서 <code>C/C++</code>을 설치  </li><li><code>다시 로드</code>를 클릭해 설치한 확장을 적용</li></ul><h4 id="5-C-C-프로젝트-폴더-생성"><a href="#5-C-C-프로젝트-폴더-생성" class="headerlink" title="5. C/C++ 프로젝트 폴더 생성"></a>5. C/C++ 프로젝트 폴더 생성</h4><ul><li>원하는 이름의 폴더 생성 후 작업영역에 추가  </li><li>폴더에 <code>test.c</code> 또는 <code>test.cpp</code> 파일 생성 후 코드 작성</li></ul><h4 id="6-컴파일-및-실행"><a href="#6-컴파일-및-실행" class="headerlink" title="6. 컴파일 및 실행"></a>6. 컴파일 및 실행</h4><ul><li>메뉴 - 터미널 - 기본 빌드 작업 구성</li><li>템플릿에서 tasks.json 파일 만들기 선택</li><li>Other 임의의 외부 명령을 실행하는 예 선택</li><li>tasks.json 생성됨</li><li><p>tasks.json을 다음 내용으로 교체하고 저장<br>* tasks.json는 위에서 생성한 프로젝트 폴더에 생성됨. 다른 폴더에서는 다시 tasks.json을 설정해 주어야 함 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;runner&quot;: &quot;terminal&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">    &quot;echoCommand&quot;: true,</span><br><span class="line">    &quot;presentation&quot; : &#123; &quot;reveal&quot;: &quot;always&quot; &#125;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;save and compile for C++&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;g++&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;$&#123;file&#125;&quot;,</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &quot;build&quot;,</span><br><span class="line">            &quot;problemMatcher&quot;: &#123;</span><br><span class="line">                &quot;fileLocation&quot;: [</span><br><span class="line">                    &quot;relative&quot;,</span><br><span class="line">                    &quot;$&#123;workspaceRoot&#125;&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;pattern&quot;: &#123;</span><br><span class="line">                    &quot;regexp&quot;: &quot;^(.*):(\\d+):(\\d+):\\s+(warning error):\\s+(.*)$&quot;,</span><br><span class="line">                    &quot;file&quot;: 1,</span><br><span class="line">                    &quot;line&quot;: 2,</span><br><span class="line">                    &quot;column&quot;: 3,</span><br><span class="line">                    &quot;severity&quot;: 4,</span><br><span class="line">                    &quot;message&quot;: 5</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;save and compile for C&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;gcc&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;$&#123;file&#125;&quot;,</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><br><span class="line">            ],</span><br><span class="line">            //&quot;group&quot;: &#123;</span><br><span class="line">            //    &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">            //    &quot;isDefault&quot;: true</span><br><span class="line">            //&#125;,</span><br><span class="line">            &quot;group&quot;: &quot;build&quot;,</span><br><span class="line">            &quot;problemMatcher&quot;: &#123;</span><br><span class="line">                &quot;fileLocation&quot;: [</span><br><span class="line">                    &quot;relative&quot;,</span><br><span class="line">                    &quot;$&#123;workspaceRoot&#125;&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;pattern&quot;: &#123;</span><br><span class="line">                    &quot;regexp&quot;: &quot;^(.*):(\\d+):(\\d+):\\s+(warning error):\\s+(.*)$&quot;,</span><br><span class="line">                    &quot;file&quot;: 1,</span><br><span class="line">                    &quot;line&quot;: 2,</span><br><span class="line">                    &quot;column&quot;: 3,</span><br><span class="line">                    &quot;severity&quot;: 4,</span><br><span class="line">                    &quot;message&quot;: 5</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;label&quot;: &quot;execute&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;cmd&quot;,</span><br><span class="line">            &quot;group&quot;: &quot;test&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;/C&quot;,</span><br><span class="line">                &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>파일 - 기본 설정 - 바로 가기 키에서 단축키 설정</p></li><li><p>keybindings.json 클릭 해 다음처럼 수정  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    //컴파일</span><br><span class="line">    &#123; &quot;key&quot;: &quot;ctrl+alt+c&quot;, &quot;command&quot;: &quot;workbench.action.tasks.build&quot; &#125;,</span><br><span class="line">    </span><br><span class="line">    //실행</span><br><span class="line">    &#123; &quot;key&quot;: &quot;ctrl+alt+r&quot;, &quot;command&quot;: &quot;workbench.action.tasks.test&quot; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>c 컴파일, 빌드</p><ul><li>test.c 파일 선택하고 <code>ctrl+alt+c</code> - save and compile for C 선택</li><li>test.exe 생성 확인 후 <code>ctrl+alt+r</code> - execute 선택</li></ul></li><li>c++ 컴파일, 빌드<ul><li>test.cpp 파일 선택하고 <code>ctrl+alt+c</code> - save and compile for C++ 선택</li><li>test.exe 생성 확인 후 <code>ctrl+alt+r</code> - execute 선택</li></ul></li></ul><h4 id="7-한글-입출력-설정"><a href="#7-한글-입출력-설정" class="headerlink" title="7. 한글 입출력 설정"></a>7. 한글 입출력 설정</h4><ul><li>메뉴 - 파일 - 기본 설정 - 설정</li><li>검색창에 unicode 입력</li><li>Files: Encoding 항목에서 utf8을 euckr로 변경</li></ul><h4 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h4><p><a href="https://taking.kr/blog/archives/4825.html" target="_blank" rel="noopener">https://taking.kr/blog/archives/4825.html</a><br><a href="https://webnautes.tistory.com/1158" target="_blank" rel="noopener">https://webnautes.tistory.com/1158</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;window 환경을 위한 VS code에서 c/c++ 컴파일 환경설정 하는법&lt;br&gt;
    
    </summary>
    
      <category term="VS code" scheme="https://Ujoy7851.github.io/categories/VS-code/"/>
    
    
      <category term="VS code" scheme="https://Ujoy7851.github.io/tags/VS-code/"/>
    
  </entry>
  
  <entry>
    <title>TOEIC 시험대비 정리 (RC)</title>
    <link href="https://Ujoy7851.github.io/2019/03/25/toeic/"/>
    <id>https://Ujoy7851.github.io/2019/03/25/toeic/</id>
    <published>2019-03-25T05:43:54.000Z</published>
    <updated>2019-03-27T14:27:30.930Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>본 포스팅은 <span class="highlight-text orange">YBM 전략 토익 RC</span>을 보고 정리한 글입니다.</p><hr><h2 id="UNIT-1-문장구조"><a href="#UNIT-1-문장구조" class="headerlink" title="# UNIT 1 문장구조"></a># UNIT 1 문장구조</h2><hr><h4 id="주어"><a href="#주어" class="headerlink" title="주어"></a>주어</h4><ul><li>명사, 대명사, 동명사구, 명사절</li></ul><h4 id="동사"><a href="#동사" class="headerlink" title="동사"></a>동사</h4><ul><li>주어 뒤에 위치</li><li>동사, 조동사+동사원형 O</li><li>to부정사, 동명사, 분사 X</li><li>자동사 + (보어)</li><li>타동사 + 목적어 + (목적어, 목적보어)</li></ul><h4 id="목적어"><a href="#목적어" class="headerlink" title="목적어"></a>목적어</h4><ul><li>타동사 뒤, 전치사 뒤에 위치</li><li>명사, 대명사, 동명사구, to부정사구, 명사절</li></ul><h4 id="보어"><a href="#보어" class="headerlink" title="보어"></a>보어</h4><ul><li>2형식 또는 5형식</li><li>형용사, 명사, to부정사, 분사, 동사원형</li></ul><blockquote><p>가주어 it: 주어가 to부정사구, that절 같이 긴 경우 주어 자리에 it을 대신 씀<br>가목적어 it: 5형식 동사 뒤 it은 가목적어로, 뒤에 진짜 목적어(to부정사, that절)이 옴</p></blockquote><h4 id="1-주어나-목적어-자리에는-명사"><a href="#1-주어나-목적어-자리에는-명사" class="headerlink" title="1. 주어나 목적어 자리에는 명사"></a>1. 주어나 목적어 자리에는 명사</h4><ul><li>주어 자리: 문장 맨 앞 또는 동사 앞쪽</li><li>목적어 자리: 타동사나 전치사 뒤</li><li>형용사/소유격/접속사 + 명사</li></ul><h4 id="2-There-is-뒤에는-명사"><a href="#2-There-is-뒤에는-명사" class="headerlink" title="2. There is 뒤에는 명사"></a>2. There is 뒤에는 명사</h4><ul><li><code>There + be동사</code>에서는 be동사 뒤가 주어 자리</li><li>is + 단수명사</li><li>are + 복수명사</li><li><code>There remain</code>, <code>There exist</code>도 뒤의 명사에 수 일치</li></ul><h4 id="3-절이-한-개면-동사도-한-개"><a href="#3-절이-한-개면-동사도-한-개" class="headerlink" title="3. 절이 한 개면 동사도 한 개"></a>3. 절이 한 개면 동사도 한 개</h4><ul><li>절에는 반드시 하나의 동사 필요</li><li>동사 O: 동사, 조동사+동사원형, be동사+ing/p.p, have+p.p</li><li>동사 X: to+동사원형, 분사(ing/p.p), 동명사</li></ul><h4 id="4-빈칸-뒤에-목적어-없으면-자동사-목적어-있으면-타동사"><a href="#4-빈칸-뒤에-목적어-없으면-자동사-목적어-있으면-타동사" class="headerlink" title="4. 빈칸 뒤에 목적어 없으면 자동사 / 목적어 있으면 타동사"></a>4. 빈칸 뒤에 목적어 없으면 자동사 / 목적어 있으면 타동사</h4><ul><li>자동사 + 부사, 전치사</li><li>타동사 + 목적어</li></ul><table><thead><tr><th>자동사</th><th>타동사</th></tr></thead><tbody><tr><td>rise, fall, arrive, function, work, emerge, commence, proceed, expire, occur, happen, take place</td><td>appoint(임명하다, 지정하다), enter, attend, announce, show, award, leave, keep, find, honor, consider, deem, make, acquire</td></tr></tbody></table><h4 id="5-be동사-뒤에는-형용사"><a href="#5-be동사-뒤에는-형용사" class="headerlink" title="5. be동사 뒤에는 형용사"></a>5. be동사 뒤에는 형용사</h4><ul><li>be동사/2형식동사 + 보어</li><li>보어: 명사, 형용사</li></ul><h4 id="6-keep-명사-뒤에는-형용사"><a href="#6-keep-명사-뒤에는-형용사" class="headerlink" title="6. keep + 명사 뒤에는 형용사"></a>6. keep + 명사 뒤에는 형용사</h4><ul><li>5형식 문장의 목적격보어: 명사, 형용사</li></ul><table><thead><tr><th>2형식 동사</th><th>5형식 동사</th></tr></thead><tbody><tr><td>be, become, turn, remain, stay, feel, prove, look, seem, appear</td><td>keep, fine, consider, deem, make, leave</td></tr></tbody></table><h4 id="7-part6-빈칸-뒤-문장의-대명사는-주로-앞-문장의-명사를-대신하는-말"><a href="#7-part6-빈칸-뒤-문장의-대명사는-주로-앞-문장의-명사를-대신하는-말" class="headerlink" title="7. part6 - 빈칸 뒤 문장의 대명사는 주로 앞 문장의 명사를 대신하는 말"></a>7. part6 - 빈칸 뒤 문장의 대명사는 주로 앞 문장의 명사를 대신하는 말</h4><hr><h2 id="UNIT-2-명사"><a href="#UNIT-2-명사" class="headerlink" title="# UNIT 2 명사"></a># UNIT 2 명사</h2><hr><h4 id="형태"><a href="#형태" class="headerlink" title="형태"></a>형태</h4><p>주로 tion, sion, ment, ance, ness, ty로 끝남  </p><h4 id="역할"><a href="#역할" class="headerlink" title="역할"></a>역할</h4><p>주어, 목적어, 보어  </p><h4 id="명사의-수"><a href="#명사의-수" class="headerlink" title="명사의 수"></a>명사의 수</h4><p>명사는 셀 수 있는 명사와 셀 수 없는 명사로 구분</p><table><thead><tr><th>가산 단수명사</th><th>가산 복수명사</th><th>불가산 명사</th></tr></thead><tbody><tr><td>앞에 반드시 한정사가 옴</td><td>뒤에 (e)s가 붙음</td><td>단수취급, 복수형태X</td></tr><tr><td>customer</td><td>price, report, rate, fee, expense, cost, fund, discount, order, load, estimate, account, permit, certificate, document, task, approach</td><td>information, equipment, merchandise, access, baggage, luggage, approval, advice, knowledge, consent, research, work, merchandise, interest, permission, machinery, furniture, money, cash</td></tr></tbody></table><h4 id="한정사"><a href="#한정사" class="headerlink" title="한정사"></a>한정사</h4><p>명사의 종류에 따른 한정사의 종류가 정해짐</p><table><thead><tr><th>구분</th><th>종류</th><th>단수 앞</th><th>복수 앞</th><th>불가산 앞</th></tr></thead><tbody><tr><td>관사</td><td>a, an</td><td>o</td><td></td><td></td></tr><tr><td></td><td>the</td><td>o</td><td>o</td><td>o</td></tr><tr><td>소유격</td><td>my, its, Joy’s</td><td>o</td><td>o</td><td>o</td></tr><tr><td>지시형용사</td><td>this, that</td><td>o</td><td></td><td>o</td></tr><tr><td></td><td>these, those</td><td></td><td>o</td><td></td></tr><tr><td>부정형용사</td><td>any, no</td><td>o</td><td>o</td><td>o</td></tr><tr><td></td><td>all, most, more, some, other</td><td></td><td>o</td><td>o</td></tr><tr><td></td><td>many, few, both, several</td><td></td><td>o</td><td></td></tr><tr><td></td><td>much, little</td><td></td><td></td><td>o</td></tr><tr><td></td><td>each, every, another, either</td><td>o</td><td></td></tr></tbody></table><h4 id="8-주목보는-명사-자리"><a href="#8-주목보는-명사-자리" class="headerlink" title="8. 주목보는 명사 자리"></a>8. 주목보는 명사 자리</h4><h4 id="9-관형명-소형명"><a href="#9-관형명-소형명" class="headerlink" title="9. 관형명 소형명"></a>9. 관형명 소형명</h4><ul><li>관사, 소유격 뒤에는 반드시 명사가 와야 함</li><li>사이에 주로 형용사가 붙음</li><li><code>관부형명</code>도 가능</li></ul><h4 id="10-estimate는-명사도-됨"><a href="#10-estimate는-명사도-됨" class="headerlink" title="10. estimate는 명사도 됨"></a>10. estimate는 명사도 됨</h4><ul><li>명사, 동사의 형태가 같은 어휘: advance, supply, recruit(신입사원,채용하다), project, support, function, delay, use, study, limit, charge, demand, benefit, request, purchase, monitor, access, approach, proceed(진행, 진행하다), proceeds(수익금)</li><li>명사, 형용사의 형태가 같은 어휘: official, individual, potential, editorial, disposable(일회용품, 처분할 수 있는), executive, alternative, specific, objective, representative, professional, characteristic</li></ul><h4 id="11-복합명사"><a href="#11-복합명사" class="headerlink" title="11. 복합명사"></a>11. 복합명사</h4><ul><li>복합명사: 두 개의 명사가 모여 하나의 명사처럼 쓰임</li><li>그냥 외워라</li></ul><h4 id="12-주어와-동사-수일치"><a href="#12-주어와-동사-수일치" class="headerlink" title="12. 주어와 동사 수일치"></a>12. 주어와 동사 수일치</h4><ul><li>단수, 불가산명사 + 단수동사</li><li>복수명사 + 복수동사</li><li>수식어가 복수여도 상관없이 동사에 수 일치 (Our reputation is ~)</li></ul><h4 id="13-불가산명사는-뒤에-e-s-붙지-않음"><a href="#13-불가산명사는-뒤에-e-s-붙지-않음" class="headerlink" title="13. 불가산명사는 뒤에 (e)s 붙지 않음"></a>13. 불가산명사는 뒤에 (e)s 붙지 않음</h4><ul><li>불가산명사는 셀 수 없으므로 단수 형태</li><li>all, many + 복수명사</li><li>much, little + 불가산명사</li><li>위에 <code>명사의 수</code> 참고</li></ul><h4 id="14-빈칸-앞에-관사-소유격이-없으면-가산-단수명사-X"><a href="#14-빈칸-앞에-관사-소유격이-없으면-가산-단수명사-X" class="headerlink" title="14. 빈칸 앞에 관사, 소유격이 없으면 가산 단수명사 X"></a>14. 빈칸 앞에 관사, 소유격이 없으면 가산 단수명사 X</h4><ul><li>가산 단수명사는 반드시 한정사 필요</li><li>한정사 없을 경우 복수형태로</li><li>불가산명사 위에 <code>명사의 수</code> 참고</li></ul><h4 id="15-보기에-명사가-여러개-gt-문맥에-맞는-걸-골라라"><a href="#15-보기에-명사가-여러개-gt-문맥에-맞는-걸-골라라" class="headerlink" title="15. 보기에 명사가 여러개 -&gt; 문맥에 맞는 걸 골라라"></a>15. 보기에 명사가 여러개 -&gt; 문맥에 맞는 걸 골라라</h4><p>ex. resident 거주자 / residence 거주, 주택<br>    correspondent 기자 / correspondence 서신</p><h4 id="16-part6-지시어가-무엇을-지칭한-말인지-확인"><a href="#16-part6-지시어가-무엇을-지칭한-말인지-확인" class="headerlink" title="16. part6 - 지시어가 무엇을 지칭한 말인지 확인"></a>16. part6 - 지시어가 무엇을 지칭한 말인지 확인</h4><p>++ 3/27 내용 추가 ++</p><hr><h2 id="UNIT-3-대명사"><a href="#UNIT-3-대명사" class="headerlink" title="# UNIT 3 대명사"></a># UNIT 3 대명사</h2><hr><h4 id="인칭대명사"><a href="#인칭대명사" class="headerlink" title="인칭대명사"></a>인칭대명사</h4><p>i, my, me, mine, myself….</p><ul><li><p>주격, 소유격, 목적격</p></li><li><p>재귀대명사</p><ul><li>재귀용법: 목적어로 쓰임, 주어와 목적어가 같을 때</li><li>강조용법: 명사 강조, 강조하는 말 바로 뒤나 문장 끝에</li></ul></li><li><p>소유대명사: 소유격+명사를 대신하는 말.</p></li></ul><h4 id="지시대명사"><a href="#지시대명사" class="headerlink" title="지시대명사"></a>지시대명사</h4><ul><li>단수: this, that</li><li>복수: these, those</li><li>that, those: 문장 내에서 앞에 나온 명사 대신함. 일반적으로 뒤에 수식어 옴</li><li>형용사 역할: 명사 앞에서 지시형용사로 쓰임<ul><li>this/that + 단수명사</li><li>these/those + 복수명사</li></ul></li></ul><h4 id="부정대명사"><a href="#부정대명사" class="headerlink" title="부정대명사"></a>부정대명사</h4><p>하나, 일부, 대부분같이 분명하게 정해지지 않은 대상을 지칭</p><table><thead><tr><th>구분</th><th>부정대명사</th></tr></thead><tbody><tr><td>단수 취급</td><td>one, each, either, another</td></tr><tr><td>복수 취급</td><td>(a) few, both, several, many</td></tr><tr><td>불가산(단수 취급)</td><td>(a) little, much</td></tr><tr><td>복수 또는 불가산</td><td>all, most, half, any, some</td></tr></tbody></table><h4 id="17-동사-앞은-주격-동사-전치사-뒤는-목적격"><a href="#17-동사-앞은-주격-동사-전치사-뒤는-목적격" class="headerlink" title="17. 동사 앞은 주격, 동사/전치사 뒤는 목적격"></a>17. 동사 앞은 주격, 동사/전치사 뒤는 목적격</h4><h4 id="18-명사-앞은-소유격"><a href="#18-명사-앞은-소유격" class="headerlink" title="18. 명사 앞은 소유격"></a>18. 명사 앞은 소유격</h4><ul><li>소형명</li><li>소유격 + own + 명사</li></ul><h4 id="19-주어와-목적어-같으면-목적어로-재귀대명사"><a href="#19-주어와-목적어-같으면-목적어로-재귀대명사" class="headerlink" title="19. 주어와 목적어 같으면 목적어로 재귀대명사"></a>19. 주어와 목적어 같으면 목적어로 재귀대명사</h4><ul><li>명령문은 주어 you가 생략되므로 재귀대명사로 yourself를 씀</li></ul><h4 id="20-주어-뒤-목적어-뒤는-재귀대명사"><a href="#20-주어-뒤-목적어-뒤는-재귀대명사" class="headerlink" title="20. 주어 뒤, 목적어 뒤는 재귀대명사"></a>20. 주어 뒤, 목적어 뒤는 재귀대명사</h4><ul><li>명사 강조. 직접, 몸소라는 뜻</li></ul><h4 id="21-by-뒤에는-재귀대명사"><a href="#21-by-뒤에는-재귀대명사" class="headerlink" title="21. by 뒤에는 재귀대명사"></a>21. by 뒤에는 재귀대명사</h4><ul><li>by oneself: 혼자서</li><li>on one’s own: 혼자서</li><li>for oneself: 스스로, 자신을 위해</li><li>in itself: 그 자체가, 본질적으로</li></ul><h4 id="22-those-who-p-p-전치사"><a href="#22-those-who-p-p-전치사" class="headerlink" title="22. those + who/p.p/전치사"></a>22. those + who/p.p/전치사</h4><ul><li>관계사절이나, 분사, 전치사구의 수식을 받아 ‘~한 사람들’이라는 뜻으로 쓰임</li><li>they, them, we, this, that 등은 이런 용도로 쓰이지 않음</li><li>anyone who + 단수동사: ~하는 누구라도</li></ul><h4 id="23-부정대명사-자리라면-수-파악"><a href="#23-부정대명사-자리라면-수-파악" class="headerlink" title="23. 부정대명사 자리라면 수 파악"></a>23. 부정대명사 자리라면 수 파악</h4><ul><li>어느 명사를 대신하는지 파악하여 수 일치</li><li>every, other은 형용사</li></ul><h4 id="24-부정대명사-표현"><a href="#24-부정대명사-표현" class="headerlink" title="24. 부정대명사 표현"></a>24. 부정대명사 표현</h4><ul><li>one - another</li><li>some - others</li><li>관사 + 형용사 + one: ~한 것</li><li>each other, one another은 주어가 될 수 없음</li></ul><h4 id="25-접속부사"><a href="#25-접속부사" class="headerlink" title="25. 접속부사"></a>25. 접속부사</h4><p>앞뒤 문장이 어떤 관계로 연결되었는지 파악하는 단서</p><table><thead><tr><th>구분</th><th>접속부사</th></tr></thead><tbody><tr><td>인과</td><td>therefore, thus, hence, consequently, as a result</td></tr><tr><td>역접</td><td>however, even so, in contrast, to the contrary, nevetheless, nonetheless</td></tr><tr><td>시간</td><td>then, afterwards, subsequently, finally</td></tr><tr><td>추가</td><td>furthermore, moreover, besides, plus, also, likewise, additionally, in addition</td></tr><tr><td>조건</td><td>if so, if not, otherwise, in this case, accordingly</td></tr><tr><td>기타</td><td>in fact, alternatively, instead, unfortunately, regrettably, after all, for example, for instance</td></tr></tbody></table><hr><h2 id="UNIT-4-동사"><a href="#UNIT-4-동사" class="headerlink" title="# UNIT 4 동사"></a># UNIT 4 동사</h2><hr><h4 id="수일치"><a href="#수일치" class="headerlink" title="수일치"></a>수일치</h4><table><thead><tr><th>구분</th><th>3인칭 단수</th><th>복수, 2인칭 단수</th></tr></thead><tbody><tr><td>be동사</td><td>is, was</td><td>are, were</td></tr><tr><td>do</td><td>does</td><td>do</td></tr><tr><td>have</td><td>has</td><td>have</td></tr><tr><td>일반</td><td>-(e)s</td><td>동사원형</td></tr></tbody></table><ul><li>수식어는 수일치와 무관</li><li>관계대명사절의 동사는 관계대명사 앞 명사에 수일치</li></ul><h4 id="수량-표현의-수일치"><a href="#수량-표현의-수일치" class="headerlink" title="수량 표현의 수일치"></a>수량 표현의 수일치</h4><p>전부나 일부를 뜻하는 부정대명사일 경우 주의!</p><ul><li>all/most/some/any + of the + 복수명사 + 복수동사</li><li>all/most/some/any + of the + 불가산명사 + 단수동사<br>ex. All of the <u>programs are</u> listed on the web site.<br>ex. All of the <u>information is</u> listed on the web site.</li><li>one, each, either, neither + of the + 복수명사 + 단수동사</li></ul><h4 id="능동태-수동태"><a href="#능동태-수동태" class="headerlink" title="능동태, 수동태"></a>능동태, 수동태</h4><ul><li>능동태: 주어 + 타동사 + 목적어</li><li>수동태: 주어 + be p.p (+ by + 행위자)</li></ul><h4 id="시제"><a href="#시제" class="headerlink" title="시제"></a>시제</h4><table><thead><tr><th>구분</th><th>현재</th><th>과거</th><th>미래</th></tr></thead><tbody><tr><td>단순</td><td>am, are, is, 동사원형(es)</td><td>was, were, 동사원형ed</td><td>will + 동사원형</td></tr><tr><td>진행</td><td>am/are/is Ving</td><td>was/were Ving</td><td>will be Ving</td></tr><tr><td>완료</td><td>have/has p.p</td><td>had p.p</td><td>will have p.p</td></tr></tbody></table><h4 id="26-동사-문제는-주어의-수-확인"><a href="#26-동사-문제는-주어의-수-확인" class="headerlink" title="26. 동사 문제는 주어의 수 확인"></a>26. 동사 문제는 주어의 수 확인</h4><h4 id="27-all-of-the-명사에서-명사에-동사의-수-일치"><a href="#27-all-of-the-명사에서-명사에-동사의-수-일치" class="headerlink" title="27. all of the 명사에서 명사에 동사의 수 일치"></a>27. all of the 명사에서 명사에 동사의 수 일치</h4><p><code>수량 표현의 수일치</code> 참고</p><h4 id="28-빈칸-뒤에-목적어-있으면-능동-없으면-수동"><a href="#28-빈칸-뒤에-목적어-있으면-능동-없으면-수동" class="headerlink" title="28. 빈칸 뒤에 목적어 있으면 능동 없으면 수동"></a>28. 빈칸 뒤에 목적어 있으면 능동 없으면 수동</h4><ul><li>타동사 뒤에 목적어 없으면 수동태</li></ul><h4 id="29-수동태-뒤에-목적어-있는-동사"><a href="#29-수동태-뒤에-목적어-있는-동사" class="headerlink" title="29. 수동태 뒤에 목적어 있는 동사"></a>29. 수동태 뒤에 목적어 있는 동사</h4><ul><li>4형식 동사는 수동태가 되도 목적어 필요</li><li>5형식 동사는 수동태 되면 뒤에 목적보어(명사, 형용사)<blockquote><p>be made ~<br>be deemed ~<br>be considered ~<br>be held ~ (~라고 생각하다)<br>be named ~</p></blockquote></li></ul><h4 id="30-명령문이나-조동사-뒤에-동사원형"><a href="#30-명령문이나-조동사-뒤에-동사원형" class="headerlink" title="30. 명령문이나 조동사 뒤에 동사원형"></a>30. 명령문이나 조동사 뒤에 동사원형</h4><ul><li>If절/When절 + 명령문: ~하면/할 때 ~해라</li><li>조동사 + 부사(not, no longer, finally, probably) + 동사원형</li></ul><h4 id="31-yesterday-있으면-과거시제"><a href="#31-yesterday-있으면-과거시제" class="headerlink" title="31. yesterday 있으면 과거시제"></a>31. yesterday 있으면 과거시제</h4><ul><li>과거시제: yesterday, ago, last, in 1999, previously, formerly, originally, initially, recently(현재완료도 가능)</li><li>현재시제: 현재의 상태, 일반적 사실, 반복적인 일을 나타냄. now, currently, every, normally, 빈도부사(usually, always, often)</li></ul><h4 id="32-over-the-past-있으면-have-p-p"><a href="#32-over-the-past-있으면-have-p-p" class="headerlink" title="32. over the past ~ 있으면 have p.p"></a>32. over the past ~ 있으면 have p.p</h4><ul><li>현재완료: 과거부터 현재까지 계속되거나 현재에 완료된 상태</li><li>over/for/during/in the past/last + 기간</li><li>since + 과거</li></ul><h4 id="33-next-있으면-will"><a href="#33-next-있으면-will" class="headerlink" title="33. next 있으면 will"></a>33. next 있으면 will</h4><ul><li>next, tomorrow, soon, until further notice, as of(~부터)</li><li>현재진행이 가까운 미래의 일정을 나타내기도 함</li></ul><h4 id="34-If-주어-현재시제-주어-will"><a href="#34-If-주어-현재시제-주어-will" class="headerlink" title="34. If + 주어 + 현재시제, 주어 + will"></a>34. If + 주어 + 현재시제, 주어 + will</h4><ul><li>If/When + 주어 + 현재시제, 주어 + will</li><li>시간 접속사: when, befor, after, while, until, as soon as</li><li>조건 접속사: if, unless, in case (that), providing(that), provided (that)</li></ul><h4 id="35-by-the-time-주어-과거시제-주어-had-p-p"><a href="#35-by-the-time-주어-과거시제-주어-had-p-p" class="headerlink" title="35. by the time + 주어 + 과거시제, 주어 + had p.p"></a>35. by the time + 주어 + 과거시제, 주어 + had p.p</h4><ul><li>과거완료: 과거의 사건보다 이전에 일어난 일<ul><li>by the time / before + 주어 + 과거시제, 주어 + had p.p</li><li>after 주어 + had p.p, 주어 + 과거시제</li></ul></li><li>미래완료<ul><li>by the time 주어 + 현재시제, 주어 + will have p.p</li></ul></li></ul><h4 id="36-빈칸-앞뒤-문장의-동사-명사를-통해-정답문장의-키워드-파악하기"><a href="#36-빈칸-앞뒤-문장의-동사-명사를-통해-정답문장의-키워드-파악하기" class="headerlink" title="36. 빈칸 앞뒤 문장의 동사, 명사를 통해 정답문장의 키워드 파악하기"></a>36. 빈칸 앞뒤 문장의 동사, 명사를 통해 정답문장의 키워드 파악하기</h4><hr><h2 id="UNIT-5-To부정사-amp-동명사"><a href="#UNIT-5-To부정사-amp-동명사" class="headerlink" title="# UNIT 5. To부정사 &amp; 동명사"></a># UNIT 5. To부정사 &amp; 동명사</h2><hr><h4 id="37-완전한-절-앞-뒤는-부사역학을-to부정사"><a href="#37-완전한-절-앞-뒤는-부사역학을-to부정사" class="headerlink" title="37. 완전한 절 앞/뒤는 부사역학을 to부정사"></a>37. 완전한 절 앞/뒤는 부사역학을 to부정사</h4><h4 id="38-allow-목적어-to부정사"><a href="#38-allow-목적어-to부정사" class="headerlink" title="38. allow + 목적어 + to부정사"></a>38. allow + 목적어 + to부정사</h4><h4 id="39-명사-형용사-to부정사"><a href="#39-명사-형용사-to부정사" class="headerlink" title="39. 명사/형용사 + to부정사"></a>39. 명사/형용사 + to부정사</h4><h4 id="40-전치사-to로-끝나는-관용표현-ing"><a href="#40-전치사-to로-끝나는-관용표현-ing" class="headerlink" title="40. 전치사 to로 끝나는 관용표현 + ing"></a>40. 전치사 to로 끝나는 관용표현 + ing</h4><h4 id="41-plan-to부정사"><a href="#41-plan-to부정사" class="headerlink" title="41. plan + to부정사"></a>41. plan + to부정사</h4><h4 id="42-consider-동명사"><a href="#42-consider-동명사" class="headerlink" title="42. consider + 동명사"></a>42. consider + 동명사</h4><h4 id="43-빈칸-뒤에-목적어-없으면-명사-있으면-동명사"><a href="#43-빈칸-뒤에-목적어-없으면-명사-있으면-동명사" class="headerlink" title="43. 빈칸 뒤에 목적어 없으면 명사, 있으면 동명사"></a>43. 빈칸 뒤에 목적어 없으면 명사, 있으면 동명사</h4><h4 id="44-전치사-동명사"><a href="#44-전치사-동명사" class="headerlink" title="44. 전치사 + 동명사"></a>44. 전치사 + 동명사</h4><h4 id="45-앞뒤-문장-동사의-시제-확인"><a href="#45-앞뒤-문장-동사의-시제-확인" class="headerlink" title="45. 앞뒤 문장 동사의 시제 확인"></a>45. 앞뒤 문장 동사의 시제 확인</h4><hr><h2 id="UNIT-6-분사"><a href="#UNIT-6-분사" class="headerlink" title="# UNIT 6. 분사"></a># UNIT 6. 분사</h2><hr><h4 id="46-명사-앞-분사-명사가-하면-ing-명사가-되면-p-p"><a href="#46-명사-앞-분사-명사가-하면-ing-명사가-되면-p-p" class="headerlink" title="46. 명사 앞 분사: 명사가 ~하면 ing, 명사가 ~되면 p.p"></a>46. 명사 앞 분사: 명사가 ~하면 ing, 명사가 ~되면 p.p</h4><h4 id="47-의미가-헷갈리는-분사"><a href="#47-의미가-헷갈리는-분사" class="headerlink" title="47. 의미가 헷갈리는 분사"></a>47. 의미가 헷갈리는 분사</h4><h4 id="48-분사가-명사를-뒤에서-수식할-때-뒤에-목적어-유무-확인"><a href="#48-분사가-명사를-뒤에서-수식할-때-뒤에-목적어-유무-확인" class="headerlink" title="48. 분사가 명사를 뒤에서 수식할 때 뒤에 목적어 유무 확인"></a>48. 분사가 명사를 뒤에서 수식할 때 뒤에 목적어 유무 확인</h4><h4 id="49-명사가-감정을-느끼면-p-p-못-느끼면-ing"><a href="#49-명사가-감정을-느끼면-p-p-못-느끼면-ing" class="headerlink" title="49. 명사가 감정을 느끼면 p.p, 못 느끼면 ing"></a>49. 명사가 감정을 느끼면 p.p, 못 느끼면 ing</h4><h4 id="50-완전한-절-앞뒤에-콤마로-연결되는-수식어구-분사구문"><a href="#50-완전한-절-앞뒤에-콤마로-연결되는-수식어구-분사구문" class="headerlink" title="50. 완전한 절 앞뒤에 콤마로 연결되는 수식어구 - 분사구문"></a>50. 완전한 절 앞뒤에 콤마로 연결되는 수식어구 - 분사구문</h4><h4 id="51-부사절-접속사-뒤에-주어-없으면-분사"><a href="#51-부사절-접속사-뒤에-주어-없으면-분사" class="headerlink" title="51. 부사절 접속사 뒤에 주어 없으면 분사"></a>51. 부사절 접속사 뒤에 주어 없으면 분사</h4><h4 id="52-문서-작성일도-단서"><a href="#52-문서-작성일도-단서" class="headerlink" title="52. 문서 작성일도 단서"></a>52. 문서 작성일도 단서</h4><hr><h2 id="UNIT-7-형용사-amp-부사"><a href="#UNIT-7-형용사-amp-부사" class="headerlink" title="# UNIT 7. 형용사 &amp; 부사"></a># UNIT 7. 형용사 &amp; 부사</h2><hr><h4 id="53-관부형명-광형형명"><a href="#53-관부형명-광형형명" class="headerlink" title="53. 관부형명 광형형명"></a>53. 관부형명 광형형명</h4><h4 id="54-timely는-형용사"><a href="#54-timely는-형용사" class="headerlink" title="54. timely는 형용사"></a>54. timely는 형용사</h4><h4 id="55-보기에-형용사-ing-p-p-있으면-형용사-1순위"><a href="#55-보기에-형용사-ing-p-p-있으면-형용사-1순위" class="headerlink" title="55. 보기에 형용사/ing/p.p 있으면 형용사 1순위"></a>55. 보기에 형용사/ing/p.p 있으면 형용사 1순위</h4><h4 id="56-every-단수명사-all-복수명사"><a href="#56-every-단수명사-all-복수명사" class="headerlink" title="56. every + 단수명사, all + 복수명사"></a>56. every + 단수명사, all + 복수명사</h4><h4 id="57-be-부사-p-p-ing-형용사"><a href="#57-be-부사-p-p-ing-형용사" class="headerlink" title="57. be 부사 p.p/ing/형용사"></a>57. be 부사 p.p/ing/형용사</h4><h4 id="58-완전한-절-앞뒤에는-부사"><a href="#58-완전한-절-앞뒤에는-부사" class="headerlink" title="58. 완전한 절 앞뒤에는 부사"></a>58. 완전한 절 앞뒤에는 부사</h4><h4 id="59-late-늦게-lately-최근에"><a href="#59-late-늦게-lately-최근에" class="headerlink" title="59. late 늦게, lately 최근에"></a>59. late 늦게, lately 최근에</h4><h4 id="60-afterwards는-부사"><a href="#60-afterwards는-부사" class="headerlink" title="60. afterwards는 부사"></a>60. afterwards는 부사</h4><h4 id="61-접속부사-문제는-앞뒤-문장의-관계보기"><a href="#61-접속부사-문제는-앞뒤-문장의-관계보기" class="headerlink" title="61. 접속부사 문제는 앞뒤 문장의 관계보기"></a>61. 접속부사 문제는 앞뒤 문장의 관계보기</h4><hr><h2 id="UNIT-8-전치사"><a href="#UNIT-8-전치사" class="headerlink" title="# UNIT 8. 전치사"></a># UNIT 8. 전치사</h2><hr><h4 id="62-완전한-절-전치사-명사구"><a href="#62-완전한-절-전치사-명사구" class="headerlink" title="62. 완전한 절 + 전치사 + 명사구"></a>62. 완전한 절 + 전치사 + 명사구</h4><h4 id="63-within-기간-before-시점"><a href="#63-within-기간-before-시점" class="headerlink" title="63. within + 기간, before + 시점"></a>63. within + 기간, before + 시점</h4><h4 id="64-동사보고-전치사-고르기"><a href="#64-동사보고-전치사-고르기" class="headerlink" title="64. 동사보고 전치사 고르기"></a>64. 동사보고 전치사 고르기</h4><h4 id="65-뒤에-보고-전치사-고르기"><a href="#65-뒤에-보고-전치사-고르기" class="headerlink" title="65. 뒤에 보고 전치사 고르기"></a>65. 뒤에 보고 전치사 고르기</h4><h4 id="66-regardless-of은-전치사"><a href="#66-regardless-of은-전치사" class="headerlink" title="66. regardless of은 전치사"></a>66. regardless of은 전치사</h4><h4 id="67-regarding-given은-전치사"><a href="#67-regarding-given은-전치사" class="headerlink" title="67. regarding, given은 전치사"></a>67. regarding, given은 전치사</h4><h4 id="68-움직이면-to-from-고정이면-in-near"><a href="#68-움직이면-to-from-고정이면-in-near" class="headerlink" title="68. 움직이면 to/from, 고정이면 in/near"></a>68. 움직이면 to/from, 고정이면 in/near</h4><h4 id="69-대상-목적-이유-용도에는-for"><a href="#69-대상-목적-이유-용도에는-for" class="headerlink" title="69. 대상/목적/이유/용도에는 for"></a>69. 대상/목적/이유/용도에는 for</h4><h4 id="70-대명사는-빈칸-앞-문장에서-명사-찾기"><a href="#70-대명사는-빈칸-앞-문장에서-명사-찾기" class="headerlink" title="70. 대명사는 빈칸 앞 문장에서 명사 찾기"></a>70. 대명사는 빈칸 앞 문장에서 명사 찾기</h4><hr><h2 id="UNIT-9-접속사"><a href="#UNIT-9-접속사" class="headerlink" title="# UNIT 9. 접속사"></a># UNIT 9. 접속사</h2><hr><h4 id="71-완전한-절-부사절-접속사-완전한-절"><a href="#71-완전한-절-부사절-접속사-완전한-절" class="headerlink" title="71. 완전한 절 + 부사절 접속사 + 완전한 절"></a>71. 완전한 절 + 부사절 접속사 + 완전한 절</h4><h4 id="72-after는-전치사-또는-부사절-접속사"><a href="#72-after는-전치사-또는-부사절-접속사" class="headerlink" title="72. after는 전치사 또는 부사절 접속사"></a>72. after는 전치사 또는 부사절 접속사</h4><h4 id="73-보기에-부사절-접속사가-여러개면-해석으로-고르기"><a href="#73-보기에-부사절-접속사가-여러개면-해석으로-고르기" class="headerlink" title="73. 보기에 부사절 접속사가 여러개면 해석으로 고르기"></a>73. 보기에 부사절 접속사가 여러개면 해석으로 고르기</h4><h4 id="74-so-that은-부사절-접속사"><a href="#74-so-that은-부사절-접속사" class="headerlink" title="74. so that은 부사절 접속사"></a>74. so that은 부사절 접속사</h4><h4 id="75-명사절-접속사-절"><a href="#75-명사절-접속사-절" class="headerlink" title="75. 명사절 접속사 + 절"></a>75. 명사절 접속사 + 절</h4><h4 id="76-that-완전한-절-what-불안한-절"><a href="#76-that-완전한-절-what-불안한-절" class="headerlink" title="76. that + 완전한 절, what + 불안한 절"></a>76. that + 완전한 절, what + 불안한 절</h4><h4 id="77-의문사-ever는-명사절-접속사-또는-부사절-접속사"><a href="#77-의문사-ever는-명사절-접속사-또는-부사절-접속사" class="headerlink" title="77. 의문사 + ever는 명사절 접속사 또는 부사절 접속사"></a>77. 의문사 + ever는 명사절 접속사 또는 부사절 접속사</h4><h4 id="78-사람명사-who-주어없는-절"><a href="#78-사람명사-who-주어없는-절" class="headerlink" title="78. 사람명사 + who + 주어없는 절"></a>78. 사람명사 + who + 주어없는 절</h4><h4 id="79-명사-whose-명사-동사"><a href="#79-명사-whose-명사-동사" class="headerlink" title="79. 명사 + whose + 명사 + 동사"></a>79. 명사 + whose + 명사 + 동사</h4><h4 id="80-audtk-most-of-whom-which-동사"><a href="#80-audtk-most-of-whom-which-동사" class="headerlink" title="80. audtk, most of + whom/which + 동사"></a>80. audtk, most of + whom/which + 동사</h4><h4 id="81-어휘-문제는-빈칸-앞뒤-문장에-정답과-유의어-있음"><a href="#81-어휘-문제는-빈칸-앞뒤-문장에-정답과-유의어-있음" class="headerlink" title="81. 어휘 문제는 빈칸 앞뒤 문장에 정답과 유의어 있음"></a>81. 어휘 문제는 빈칸 앞뒤 문장에 정답과 유의어 있음</h4><hr><h2 id="UNIT-10-특수구문"><a href="#UNIT-10-특수구문" class="headerlink" title="# UNIT 10. 특수구문"></a># UNIT 10. 특수구문</h2><hr><h4 id="82-and는-앞뒤로-대등한-품사-연결"><a href="#82-and는-앞뒤로-대등한-품사-연결" class="headerlink" title="82. and는 앞뒤로 대등한 품사 연결"></a>82. and는 앞뒤로 대등한 품사 연결</h4><h4 id="83-not-only-but-also"><a href="#83-not-only-but-also" class="headerlink" title="83. not only ~ but also"></a>83. not only ~ but also</h4><h4 id="84-as-원급-as"><a href="#84-as-원급-as" class="headerlink" title="84. as + 원급 + as"></a>84. as + 원급 + as</h4><h4 id="85-원급-비교과-관련된-관용-표현"><a href="#85-원급-비교과-관련된-관용-표현" class="headerlink" title="85. 원급 비교과 관련된 관용 표현"></a>85. 원급 비교과 관련된 관용 표현</h4><h4 id="86-비교급-than"><a href="#86-비교급-than" class="headerlink" title="86. 비교급 + than"></a>86. 비교급 + than</h4><h4 id="87-the-최상급"><a href="#87-the-최상급" class="headerlink" title="87. the + 최상급"></a>87. the + 최상급</h4><h4 id="88-If-주어-had-p-p-주어-would-have-p-p"><a href="#88-If-주어-had-p-p-주어-would-have-p-p" class="headerlink" title="88. If + 주어 + had p.p, 주어 + would have p.p"></a>88. If + 주어 + had p.p, 주어 + would have p.p</h4><h4 id="89-should-주어-동사원형-명령문"><a href="#89-should-주어-동사원형-명령문" class="headerlink" title="89. should + 주어 + 동사원형, 명령문"></a>89. should + 주어 + 동사원형, 명령문</h4><h4 id="90-문법-문제는-한-문장-안에서-해결"><a href="#90-문법-문제는-한-문장-안에서-해결" class="headerlink" title="90. 문법 문제는 한 문장 안에서 해결"></a>90. 문법 문제는 한 문장 안에서 해결</h4><hr><h2 id="UNIT-11-어휘1"><a href="#UNIT-11-어휘1" class="headerlink" title="# UNIT 11. 어휘1"></a># UNIT 11. 어휘1</h2><hr><h4 id="91-제안-요구-동사-that-동사원형"><a href="#91-제안-요구-동사-that-동사원형" class="headerlink" title="91. 제안/요구 동사 + that + 동사원형"></a>91. 제안/요구 동사 + that + 동사원형</h4><h4 id="92-자동사-전치사-표현"><a href="#92-자동사-전치사-표현" class="headerlink" title="92. 자동사 + 전치사 표현"></a>92. 자동사 + 전치사 표현</h4><h4 id="93-inform의-목적어는-을-를-아니고-에게"><a href="#93-inform의-목적어는-을-를-아니고-에게" class="headerlink" title="93. inform의 목적어는 ~을/를 아니고 ~에게"></a>93. inform의 목적어는 <code>~을/를</code> 아니고 <code>~에게</code></h4><h4 id="94-address-issue는-짝꿍"><a href="#94-address-issue는-짝꿍" class="headerlink" title="94. address, issue는 짝꿍"></a>94. address, issue는 짝꿍</h4><h4 id="95-동사-고를-때-뒤의-전치사-확인"><a href="#95-동사-고를-때-뒤의-전치사-확인" class="headerlink" title="95. 동사 고를 때 뒤의 전치사 확인"></a>95. 동사 고를 때 뒤의 전치사 확인</h4><h4 id="96-전치사-덩어리-표현"><a href="#96-전치사-덩어리-표현" class="headerlink" title="96. 전치사 덩어리 표현"></a>96. 전치사 덩어리 표현</h4><h4 id="97-require-목적어-to부정사"><a href="#97-require-목적어-to부정사" class="headerlink" title="97. require + 목적어 + to부정사"></a>97. require + 목적어 + to부정사</h4><h4 id="98-빈칸-뒤-to부정사"><a href="#98-빈칸-뒤-to부정사" class="headerlink" title="98. 빈칸 뒤 to부정사"></a>98. 빈칸 뒤 to부정사</h4><hr><h2 id="UNIT-12-어휘2"><a href="#UNIT-12-어휘2" class="headerlink" title="# UNIT 12. 어휘2"></a># UNIT 12. 어휘2</h2><hr><h4 id="99-닮은꼴-형용사-주의"><a href="#99-닮은꼴-형용사-주의" class="headerlink" title="99. 닮은꼴 형용사 주의"></a>99. 닮은꼴 형용사 주의</h4><h4 id="100-형용사-전치사"><a href="#100-형용사-전치사" class="headerlink" title="100. 형용사 + 전치사"></a>100. 형용사 + 전치사</h4><h4 id="101-extensive-experience는-짝꿍"><a href="#101-extensive-experience는-짝꿍" class="headerlink" title="101. extensive, experience는 짝꿍"></a>101. extensive, experience는 짝꿍</h4><h4 id="102-명사-전치사"><a href="#102-명사-전치사" class="headerlink" title="102. 명사 + 전치사"></a>102. 명사 + 전치사</h4><h4 id="103-현재시제에는-빈도부사-넣어보기"><a href="#103-현재시제에는-빈도부사-넣어보기" class="headerlink" title="103. 현재시제에는 빈도부사 넣어보기"></a>103. 현재시제에는 빈도부사 넣어보기</h4><h4 id="104-부사-짝꿍"><a href="#104-부사-짝꿍" class="headerlink" title="104. 부사 짝꿍"></a>104. 부사 짝꿍</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;시험 직전 빠르게 훑기&lt;/p&gt;
    
    </summary>
    
      <category term="Toeic" scheme="https://Ujoy7851.github.io/categories/Toeic/"/>
    
    
      <category term="toeic" scheme="https://Ujoy7851.github.io/tags/toeic/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Tranquilpeak 테마 적용하기</title>
    <link href="https://Ujoy7851.github.io/2019/03/24/hexo-theme/"/>
    <id>https://Ujoy7851.github.io/2019/03/24/hexo-theme/</id>
    <published>2019-03-24T11:48:42.000Z</published>
    <updated>2019-03-27T14:31:39.762Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><p>hexo로 만들어진 블로그들을 구경하다가 ‘Tranquilpeak’ 테마를 발견하고 따라서 적용해보았다. 그 과정에서 많은 시행착오를 겪었고 나같은 사람들이 더 이상 생기지 않길 바라는 마음에서 정리해보았다.</p><h2 id="Tranquilpeak-테마-설치하기"><a href="#Tranquilpeak-테마-설치하기" class="headerlink" title="#Tranquilpeak 테마 설치하기"></a>#Tranquilpeak 테마 설치하기</h2><h4 id="최신버전-다운로드"><a href="#최신버전-다운로드" class="headerlink" title="최신버전 다운로드"></a>최신버전 다운로드</h4><p>다른 테마들과 다르게 Tranquilpeak 테마는 github에서 바로 clone해서 적용하면 안된다.<br>아래 링크에 가서 최신버전의 .zip 파일을 다운받은 뒤 themes 폴더에 압축을 풀고 tranquilpeak으로 이름을 변경한다.<br><a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/releases" target="_blank" rel="noopener">Download</a></p><h4 id="설정파일-수정"><a href="#설정파일-수정" class="headerlink" title="설정파일 수정"></a>설정파일 수정</h4><p>hexo 환경설정 파일인 _config.yml에서 테마 관련내용을 수정한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: tranquilpeak</span><br></pre></td></tr></table></figure></p><h4 id="node-sass-hexo-renderer-sass-설치"><a href="#node-sass-hexo-renderer-sass-설치" class="headerlink" title="node-sass, hexo-renderer-sass 설치"></a>node-sass, hexo-renderer-sass 설치</h4><p>hexo 루트폴더에 설치해준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save node-sass</span><br><span class="line"></span><br><span class="line">npm install --save hexo-renderer-sass</span><br></pre></td></tr></table></figure></p><hr><h2 id="Sidebar-설정-변경하기"><a href="#Sidebar-설정-변경하기" class="headerlink" title="#Sidebar 설정 변경하기"></a>#Sidebar 설정 변경하기</h2><p>테마를 처음 적용하면 home 페이지 좌측에 커다란 sidebar가 고정되어있다.<br>테마폴더의 _config.xml을 수정하면 sidebar의 크기를 줄이거나 버튼이 눌렀을 때만 sidebar가 나오도록 할 수 있다.<br>이 블로그는 현재 4로 설정되어 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sidebar_behavior: 4</span><br></pre></td></tr></table></figure></p><hr><h2 id="프로필-사진과-설명-변경하기"><a href="#프로필-사진과-설명-변경하기" class="headerlink" title="#프로필 사진과 설명 변경하기"></a>#프로필 사진과 설명 변경하기</h2><p>테마폴더의 _config.xml에서 다음과 같이 수정하면 sidebar에 표시되는 프로필 사진이 변경된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">author:</span><br><span class="line">    picture: image.png</span><br></pre></td></tr></table></figure></p><p>이때 hexo 루트폴더의 source 폴더아래 assets/images 폴더를 만들고 image.png 파일을 넣어주어야 한다.<br>사진 아래 표시되는 설명내용은<br>themes/tranquilpeak/languages 경로아래 en.yml 파일을 통해 수정해준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">author:</span><br><span class="line">    bio: &quot;기억력을 믿지 못해 블로그를 시작했다.&quot;</span><br><span class="line">    job: &quot;student&quot;</span><br></pre></td></tr></table></figure></p><hr><h2 id="front-matter-머리말-레이아웃-설정하기"><a href="#front-matter-머리말-레이아웃-설정하기" class="headerlink" title="#front matter(머리말) 레이아웃 설정하기"></a>#front matter(머리말) 레이아웃 설정하기</h2><p>scaffolds 폴더의 post.md에서 레이아웃을 설정해주면 새로운 post를 만들때마다 설정한대로 머리말이 생성된다.<br>기본은 다음과 같고 테마에 따라 다양한 옵션을 추가할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h4 id="tags"><a href="#tags" class="headerlink" title="tags"></a>tags</h4><p>글 내용과 관련된 tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tags:</span><br><span class="line">- 태그명1</span><br><span class="line">- 태그명2</span><br></pre></td></tr></table></figure></p><h4 id="categories"><a href="#categories" class="headerlink" title="categories"></a>categories</h4><p>글의 카테고리<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- 카테고리명1</span><br><span class="line">- 카테고리명2</span><br></pre></td></tr></table></figure></p><h4 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a>keywords</h4><p>search engine을 위한 키워드<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keywords:</span><br><span class="line">- 키워드1</span><br><span class="line">- 키워드2</span><br></pre></td></tr></table></figure></p><p>이 외에 다양한 옵션들은 <a href="https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak/blob/master/DOCUMENTATION.md" target="_blank" rel="noopener">여기</a>서 확인가능</p><hr><h2 id="썸네일-적용하기"><a href="#썸네일-적용하기" class="headerlink" title="#썸네일 적용하기"></a>#썸네일 적용하기</h2><p>front matter에 다음 내용을 추가한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thumbnailImage: image.png</span><br><span class="line">thumbnailImagePosition: right</span><br></pre></td></tr></table></figure></p><ul><li>썸네일의 위치는 right, left, bottom 중 하나를 선택한다.</li><li>썸네일의 적용을 위해서는 _post 폴더아래 post의 파일명과 같은 폴더를 생성하고 그 안에 thumbnailImage를 넣어주어야 한다.</li><li>예를들어, post1.md에 썸네일을 적용하고 싶은 경우 _post 폴더에 post1 폴더를 만들고 그 안에 image.png를 넣는다. 이때, post1.md는 post1이 아닌 _post 폴더에 있어야 함.</li><li>마지막으로 루트폴더의 _config.yml에서 다음과 같이 수정해주어야 썸네일이 적용된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Continue-reading-버튼"><a href="#Continue-reading-버튼" class="headerlink" title="#Continue reading 버튼"></a>#Continue reading 버튼</h2><p>포스트를 길게 작성하고 인덱스 페이지에 가보면 글의 내용이 전부 표시되어 글 목록을 한눈에 파악하기 어렵다.<br><code>&lt;!-- more --&gt;</code>과 <code>&lt;!-- excerpt --&gt;</code>를 이용하면 포스트의 일부내용만 표시되도록 할 수 있다.</p><ul><li><code>&lt;!-- more --&gt;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">어쩌고 저쩌고1</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">어쩌고 저쩌고2</span><br></pre></td></tr></table></figure></li></ul><p>포스트 중간에 <code>&lt;!-- more --&gt;</code>을 넣어주면 인덱스 페이지에서는 어쩌고 저쩌고1의 내용만 표시된다.<br>포스트에서는 어쩌고 저쩌고1과 어쩌고 저쩌고2의 내용 모두 보여진다.</p><ul><li><code>&lt;!-- excerpt --&gt;</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">어쩌고 저쩌고1</span><br><span class="line">&lt;!-- excerpt --&gt;</span><br><span class="line">어쩌고 저쩌고2</span><br></pre></td></tr></table></figure></li></ul><p>포스트 중간에 <code>&lt;!-- excerpt --&gt;</code>을 넣어주면 인덱스 페이지에서는 어쩌고 저쩌고1의 내용만 표시된다.<br>포스트에서는 어쩌고 저쩌고1의 내용은 표시되지 않고 어쩌고 저쩌고2의 내용만 보여진다.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;테마 적용하면서 겪은 시행착오들을 정리해놓은 포스팅&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://Ujoy7851.github.io/categories/Git/"/>
    
    
      <category term="hexo" scheme="https://Ujoy7851.github.io/tags/hexo/"/>
    
      <category term="tranquilpeak" scheme="https://Ujoy7851.github.io/tags/tranquilpeak/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Github page로 블로그 시작하기</title>
    <link href="https://Ujoy7851.github.io/2019/03/19/hexo/"/>
    <id>https://Ujoy7851.github.io/2019/03/19/hexo/</id>
    <published>2019-03-19T07:18:38.206Z</published>
    <updated>2019-04-03T14:59:22.916Z</updated>
    
    <content type="html"><![CDATA[<!-- excerpt --><h2 id="Git-page"><a href="#Git-page" class="headerlink" title="#Git page"></a>#Git page</h2><h4 id="Github-repository-생성"><a href="#Github-repository-생성" class="headerlink" title="Github repository 생성"></a>Github repository 생성</h4><ul><li>new repository</li><li>repository 이름을 USERNAME.github.io</li><li>create repository</li></ul><hr><h2 id="Hexo"><a href="#Hexo" class="headerlink" title="#Hexo"></a>#Hexo</h2><h4 id="사전설치"><a href="#사전설치" class="headerlink" title="사전설치"></a>사전설치</h4><ul><li>Node.js, npm</li><li>Git</li></ul><h4 id="Hexo-CLI-설치-및-블로그-생성"><a href="#Hexo-CLI-설치-및-블로그-생성" class="headerlink" title="Hexo CLI 설치 및 블로그 생성"></a>Hexo CLI 설치 및 블로그 생성</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h4 id="설정파일-업데이트"><a href="#설정파일-업데이트" class="headerlink" title="설정파일 업데이트"></a>설정파일 업데이트</h4><p>root 디렉토리에 생성된 _config.yml이라는 파일을 다음과 같이 수정</p><ul><li><p>Site 정보 - 블로그 이름과 소개</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 블로그 이름</span><br><span class="line">subtitle: </span><br><span class="line">description:</span><br><span class="line">author:</span><br></pre></td></tr></table></figure></li><li><p>URL 정보</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url: https://username.github.io</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></li><li><p>Github 정보 - 본인의 Git page의 정보를 입력</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/username/username.github.io</span><br></pre></td></tr></table></figure></li></ul><h4 id="로컬에서-테스트"><a href="#로컬에서-테스트" class="headerlink" title="로컬에서 테스트"></a>로컬에서 테스트</h4><p>로컬에서 서버를 실행시켜 블로그 확인<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp; hexo server</span><br></pre></td></tr></table></figure></p><p><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p><h4 id="Hexo-deployer-설치"><a href="#Hexo-deployer-설치" class="headerlink" title="Hexo deployer 설치"></a>Hexo deployer 설치</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm insatll hexo-deployer-git --save</span><br></pre></td></tr></table></figure><hr><h2 id="Post-작성-및-배포하기"><a href="#Post-작성-및-배포하기" class="headerlink" title="#Post 작성 및 배포하기"></a>#Post 작성 및 배포하기</h2><h4 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h4><p>source/_posts 폴더에 markdown 파일 생성됨<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure></p><h4 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">또는</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h4 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br><span class="line">또는 </span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h4 id="Theme-변경시-또는-페이지-업데이트-안될-경우"><a href="#Theme-변경시-또는-페이지-업데이트-안될-경우" class="headerlink" title="Theme 변경시 또는 페이지 업데이트 안될 경우"></a>Theme 변경시 또는 페이지 업데이트 안될 경우</h4><p>hexo를 clean하고 재배포해야 적용됨</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo deploy --generate (Generate와 Deploy 동시에 실행)</span><br><span class="line">또는</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><hr><h2 id="테마-변경하기"><a href="#테마-변경하기" class="headerlink" title="#테마 변경하기"></a>#테마 변경하기</h2><h4 id="원하는-테마-선택"><a href="#원하는-테마-선택" class="headerlink" title="원하는 테마 선택"></a>원하는 테마 선택</h4><pre><code>https://hexo.io/themes/index.html</code></pre><p>해당 테마의 github로 이동해 설명 참고</p><h4 id="테마설치"><a href="#테마설치" class="headerlink" title="테마설치"></a>테마설치</h4><p>블로그를 생성했던 폴더로 이동해 themes 폴더에 github에 있는 소스 clone (아래 코드는 clean-blog라는 테마를 적용했다)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/klugjo/hexo-theme-clean-blog.git clean-blog</span><br></pre></td></tr></table></figure></p><ul><li>theme 폴더를 보면 기본으로 적용되는 landscape 테마 폴더 존재함</li><li>여러개의 테마 폴더가 있어도 상관없음<blockquote><p>현재 이 블로그는 ‘tranquilpeak’이라는 테마를 적용함 (심플하고 이쁘지만 세세한 설정하는데 꽤 많은 시간이 소요되었다…)</p></blockquote></li></ul><h4 id="테마설정"><a href="#테마설정" class="headerlink" title="테마설정"></a>테마설정</h4><ul><li>themes/clean-blog 경로에 있는 _config.yml 수정해 테마 설정</li><li>블로그의 최상위 경로에 있는 _config.yml 수정해서 블로그에 테마 적용</li></ul><h4 id="Tags-페이지-생성"><a href="#Tags-페이지-생성" class="headerlink" title="Tags 페이지 생성"></a>Tags 페이지 생성</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page <span class="string">"tags"</span></span><br></pre></td></tr></table></figure><p>page를 생성하면 source 경로에 tags 폴더가 생기고 index.md 파일 생성됨. 아래처럼 수정</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="Categories-페이지-생성"><a href="#Categories-페이지-생성" class="headerlink" title="Categories 페이지 생성"></a>Categories 페이지 생성</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page <span class="string">"categories"</span></span><br></pre></td></tr></table></figure><p>page를 생성하면 source 경로에 tags 폴더가 생기고 index.md 파일 생성됨</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="테마-적용"><a href="#테마-적용" class="headerlink" title="테마 적용"></a>테마 적용</h4><p>블로그 최상단 폴더의 _config.yml 수정<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: clean-blog</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><hr><p>참고사이트</p><p><a href="https://hexo.io" target="_blank" rel="noopener">https://hexo.io</a></p><p><a href="https://www.holaxprogramming.com/2017/04/16/github-page-and-hexo/" target="_blank" rel="noopener">https://www.holaxprogramming.com/2017/04/16/github-page-and-hexo/</a></p><p><a href="https://kdydesign.github.io/2017/07/07/hexo-themes/#" target="_blank" rel="noopener">https://kdydesign.github.io/2017/07/07/hexo-themes/#</a></p><p><a href="https://jeyolog.github.io/2018/08/11/tranquilpeak-configuration/" target="_blank" rel="noopener">https://jeyolog.github.io/2018/08/11/tranquilpeak-configuration/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo와 Github page를 이용하여 블로그를 생성하는 방법에 대한 포스팅&lt;br&gt;생각보다 쉽지 않은 여정이었다.&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://Ujoy7851.github.io/categories/Git/"/>
    
    
      <category term="hexo" scheme="https://Ujoy7851.github.io/tags/hexo/"/>
    
      <category term="github page" scheme="https://Ujoy7851.github.io/tags/github-page/"/>
    
  </entry>
  
</feed>
